<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring Boot 공부</title>
    <link rel="stylesheet" href="./css/index.css" />
</head>
<body>
    <section id="intro">
        <header class="note_title">스프링 부트</header>
        <ul>
            <li>스프링 부트의 특징
                <pre>
                    ● 스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용
                    ● 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
                    ● Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
                    ● 손쉬운 빌드 구성을 위한 Starter 종속성 재공
                    ● 스프링 3rd path (외부) 라이브러리 자동 구성
                    ● 메트릭, 상태 확인, 외부 구성같은 프로덕션 준비 기능 제공
                    ● 관례에 의한 간결한 설정
                </pre>
            </li>
            <li>스프링 부트 설치하기
                <pre>
                    1. 이클립스 최상단의 Help 메뉴에서 Eclipse Marketplace 선택하기
                    2. STS (Spring Tool Suite)를 검색한 후에 해당 확장 모듈 설치하기
                </pre>
            </li>
            <li>스프링 부트 프로젝트 생성하기 - 1
                <pre>
                    1. 이클립스 최상단의 File 메뉴의 New 메뉴에서 Spring Starter Project 선택하기
                    2. Name 속성에 프로젝트명을 작성한 후에 해당 프로젝트에 맞게 기본 설정을 세팅한 다음에 Next를 누른다.
                        ● type : 프로젝트 관리도구를 Maven과 Gradle중 선택
                            ○ Maven
                            ○ Gradle
                        ● Packaging : 프로젝트 빌드시 패키지의 형식
                            ○ Jar
                            ○ War
                        ● Java Version : 사용할 Java의 Version 선택
                        ● Language : 사용할 프로그래밍 언어 선택
                            ○ Java
                            ○ Kotlin
                            ○ Groovy
                        ● Group : 프로젝트의 큰 틀 (예시 : com.example)
                        ● Java Version : 프로젝트의 최상위 패키지 (예시 : com.example.demo)
                    3. 프로젝트에 필요한 라이브러리(Dependency)항목들을 선택한 후에 Finish를 누른다.

                    ※ 기본적으로 선택해야 하는 라이브러리 항목
                        1. Web : @*Mapping 어노테이션때문에 필요
                        2. JDBC
                        3. ORM 계열
                        4. DBMS 계열
                    ※ 추천하는 라이브러리 항목
                        ● xxx
                        ● xxx
                        ● xxx
                </pre>
            </li>
            <li>스프링 부트 프로젝트 생성하기 - 2
                <pre>
                    ● start.spring.io로 이동하기
                    ● SNAPSHOT이나 M1은 아직 개발이 미완료된 버전
                    ● Dependencies에서 Spring Web 받기
                </pre>
            </li>
            <li>스프링 부트 설정하기
                <pre>
                    1. 스프링 부트 프로젝트 생성 완료
                    2. Spring Boot에선 기본적으로 JSP VIEW를 지원하지 않기 때문에 pom.xml에 dependency를 추가
                        &lt;dependency>
                            &lt;groupId>org.apache.tomcat.embed&lt;/groupId>
                            &lt;artifactId>tomcat-embed-jasper&lt;/artifactId>
                        &lt;/dependency>
                        &lt;dependency>
                            &lt;groupId>jstl&lt;/groupId>
                            &lt;artifactId>jstl&lt;/artifactId>
                            &lt;version>1.2&lt;/version>
                        &lt;/dependency>
                    3. application.properties에 가서 속성 추가
                        server.port=포트번호
    
                        spring.mvc.view.prefix=/WEB-INF/views/
                        spring.mvc.view.suffix=.jsp
                    4. src/main/java에 컨트롤러 패키지 및 클래스 생성
                    5. src/main에 webapp/WEB-INF/views 폴더 생성 후 해당 폴더에 jsp 파일 생성
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="validation">
        <header class="note_title">유효성 검증</header>
        <ul>
            <li>유효성 검증(validation)이란?
                <pre>
                    ● 오류를 방지하기 위해 미리 검증을 하는 과정
                </pre>
            </li>
            <li>유효성 검증에 대한 주의점
                <pre>
                    ● 검증해야 할 값이 많은 경우 코드의 길이가 길어진다.
                    ● 구현에 따라서 달라질 수도 있겠지만 Service Logic과의 분리가 필요하다.
                    ● 검증하는 코드가 흩어져 있는 경우 검증 위치가 불분명하며 재사용의 한계가 생긴다.
                    ● 구현 방식에 따라 다르겠지만 Validation Logic이 변경되면 참조하는 클래스에서 Logic이 변경되어야 하는 부분이 발생할 수 있다.
                    ● (중요 ★) 별로의 Logic이 필요한 어노테이션들 중에서 다른 VO 객체에서도 반복되는 내용이 있다면 아예 커스텀 어노테이션과 유효성 검증 클래스를 만드는 것이 낫다.
                </pre>
            </li>
            <li>필요 dependency
                <pre>
                    &lt;dependency>
                        &lt;groupId>org.springframework.boot&lt;/groupId>
                        &lt;artifactId>spring-boot-starter-validation&lt;/artifactId>
                    &lt;/dependency>
                </pre>
            </li>
            <li>유효성 검증 어노테이션
                <pre>
                    ● 길이 측정
                        ○ @Size(min="최솟값", max="최댓값") : 문자 길이 설정 : int Type 사용불가
                    ● null 또는 공백 여부 확인
                        ○ @NotNull : null 사용불가
                        ○ @NotEmpty : null & "" 사용불가
                        ○ @NotBlank : null & "" & " " 사용불가
                    ● 날짜 확인
                        ○ @Past : 과거 날짜
                        ○ @PastOrPresent : 과거 날짜 또는 오늘 날짜
                        ○ @Future : 미래 날짜
                        ○ @FutureOrPresent : 미래 날짜 또는 오늘 날짜
                    ● 데이터 차이 비교
                        ○ @Max(value="숫자") : 최댓값
                        ○ @Min(value="숫자") : 최솟값
                    ● 별도 Logic에 따른 유효성 검증
                        ○ @Pattern(regexp = "정규식") : 정규식 적용
                        ○ @AssertTure / @AssertFalse : 별도 Logic 적용
                        ○ @Valid : 해당 Object Validation 실행 (= 해당 어노테이션을 붙인 객체에 대해서 검사)
                    ● 형식
                        ○ @Email : 이메일 형식

                    ※ 공통 속성
                        ○ message : validation이 실패할 경우 반환되는 default 메세지
                        ○ payload : 특정 validation을 group을 지정하는 값
                        ○ groups : 사용자가 추가 정보를 위해 전달할 수 있는 값, 주로 심각도를 나타낼 때 사용
                </pre>
            </li>
            <li>사용 예시
                <pre>
                    ● @AssertTure(message="yyyyMMdd의 형식에 맞지 않습니다.")
                        private String birthday;
                        public String getBirthday() { return birthday; }
                        public void setBirthday(String birthday) { this.birthday = birthday; }
                        //boolean 형식 메소드명은 is로 시작해야 한다.
                        @AssertTrue
                        public boolean isBirthday(){
                            try {
                                LocalDate localDate = LocalDate.parse(getBirthday(), DateTimeFormatter.ofPattern("yyyyMMdd"));
                            } catch (Exception e) {
                                return false;
                            }
                            
                            return true;
                        }
                </pre>
            </li>
            <li>Custom Validator
                <pre>
                    1. validatior용 패키지를 만든다.
                    2. 해당 패키지에 유효성 검사용 자바 클래스를 만든다.
                    3. 해당 클래스에 ConstraintValidator 인터페이스를 구현한다.
                    4. ConstraintValidator에는 두 값이 필요한데 첫번째는 검증에 필요한 어노테이션의 종류고 두번째는 해당 어노테이션을 통해 들어올 값의 자료형이다.
                    5. initialize 메소드와 isValid 메소드를 오버라이딩한 다음에 필요한 코드를 작성한다.
                        ● initialize :
                            ○ 어노테이션 등록시 값을 초기화하는 메소드
                        ● isValid :
                            ○ 어노테이션 등록시 해당 값을 검증하는 메소드
                            ○ addConstraintViolation(ConstraintValidatorContext 변수, 전달할 메세지, "키 값"...)를 통해서 에러 메세지 전달 가능
                            ○ addConstraintViolation의 키 값들은 ErrorResponse의 errors[].field에 바인딩된다.
                    6. 해당 validatior를 사용할 어노테이션 파일에 가서 @Constraint 어노테이션의 validatedBy 속성의 {} 안에 추가해주면 된다.
                        예시) @Constraint(validatedBy = { BirthdayValidator.class })
                    7. 해당 validatior를 연결시킨 어노테이션을 필요한 곳에 추가해서 사용하면 된다.
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="exception">
        <header class="note_title">예외 처리</header>
        <ul>
            <li>예외처리 어노테이션
                <pre>
                    ● @ContrllerAdvice : Global 예외처리, 특정 패키지/컨트롤러 예외처리
                        ○ @ContrllerAdvice : @Contrller에 대해 사용하는 어노테이션
                        ○ @RestContrllerAdvice : @RestContrller에 대해 사용하는 어노테이션
                    ● @ExceptionHandler : 특정 컨트롤러의 예외처리
                </pre>
            </li>
            <li>@ExceptionHandler 기본 코드
                <pre>
                    @ExceptionHandler(value=예외종류.class)
                    public ResponseEntity exception(예외종류 e) {
                        //원하는 예외 클래스의 종류를 모를 때는 Exception e로 매개변수를 주고 e.getClass().getName()를 확인해보면 된다.
                        return ResponseEntity.status(HttpStatus.에러코드).body(e.getMessage());
                    }
                </pre>
            </li>
            <li>작동 방식
                <pre>
                    ● @ContrllerAdvice 어노테이션이 선언된 클래스 내부에 @ExceptionHandler가 선언된 메소드는 모든 컨트롤러에 대해서 적용된다.
                    ● @ContrllerAdvice 어노테이션이 모든 컨트롤러에 대해서 적용되긴 하지만
                      만약 @ContrllerAdvice가 있는 클래스에 있는 @ExceptionHandler와
                      개별의 컨트롤러에 있는 @ExceptionHandler가 같은 exception에 대해서 처리한다고 했을 때,
                      개별의 컨트롤러 쪽에 있는 @ExceptionHandler가 우선적용된다.
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="filter">
        <header class="note_title">필터</header>
        <ul>
            <li>필터 (filter)
                <pre>
                    ● Web Application에서 관리되는 영역
                    ● 인터셉터는 DispatcherServlet이 실행되기 전에 호출된다.
                    ● Spring Boot Framework에서 클라이언트로부터 오는 요청/응답에 대해서 최초/최종 단계의 위치에 존재한다.
                    ● Filter를 통해서 요청/응답의 정보를 변경할수 있다.
                    ● Spring에 의해서 데이터가 변환되기 전의 순수한 클라이언트의 요청/응답 값을 확인 할 수 있다.
                    ● 유일하게 ServletRequest/ServletResponse 객체를 변환할 수 있다.
                    ● Filter에서는 주로 request/response의 logging 용도나 인증 logic 처리를 한다.
                    ● Filter에서 logic을 처리함으로써 Service Business Logic과 분리한다.
                </pre>
            </li>
            <li>필터 구현하기
                <pre>
                    1. javax.servlet.Filter의 Filter 인터페이스를 구현한 클래스를 만든다.
                    2. 상황에 맞는 메소드를 오버라이딩한다.
                        ○ public void init(FilterConfig filterConfig) : 필터를 웹 콘테이너에 생성 후 초기화할 때 호출되는 메소드
                        ○ public void doFilter(ServletRequest request, SevletResponse response, FilterChain chain) :
                            ○ request, response에 대한 필터링 로직을 작성하는 메소드
                            ○ resquest, response가 체인을 통과할 때 마다 서블릿 컨테이너에서 호출된다.
                            ○ FilterChain으로 연결한다.
                            ○ 필터링 로직을 사용하지 않을 때에는 요청을 servlet으로 보내지 않고 바로 응답하게 한다.
                        ○ public void destroy() : 필터가 웹 콘테이너에서 삭제될 때 호출되는 메소드

                    ● doFilter 예시
                        @Override
                        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
                            ContentCachingRequestWrapper wrappingRequest = new ContentCachingRequestWrapper((HttpServletRequest)request);
                            ContentCachingResponseWrapper wrappingResponse = new ContentCachingResponseWrapper((HttpServletResponse) response);
                    
                            chain.doFilter(wrappingRequest, wrappingResponse);
                    
                            System.out.println(new String(wrappingRequest.getContentAsByteArray(),"UTF-8"));

                            System.out.println(new String(wrappingResponse.getContentAsByteArray(),"UTF-8"));
                            
                            wrappingResponse.copyBodyToResponse();
                        }
                </pre>
            </li>
            <li>필터 적용하기
                <pre>
                    1. @SpringBootApplication이 적용된 클래스에 가서 @ServletComponentScan을 추가한다.
                    2. Filter를 구현한 클래스에 가서 @WebFilter(urlPatterns="url 주소")를 추가한다. (url 주소는 String 배열로 줄 수도 있다.)
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="interceptor">
        <header class="note_title">인터셉터</header>
        <ul>
            <li>인터셉터 (interceptor)
                <pre>
                    ● 컨트롤러에 들어오는 요청 HttpRequest와 컨트롤러가 응답하는 HttpResponse를 가로채는 기능
                    ● Interceptor는 DispatcherServlet이 실행된 후에 호출된다.
                    ● Interceptor에서 logic을 처리함으로써 Service Business Logic과 분리한다.
                </pre>
            </li>
            <li>인터셉터 구현하기
                <pre>
                    1. HandlerInterceptor 인터페이스를 구현한 인터셉터용 클래스를 추가한다.
                    2. 해당 클래스에 @Component 어노테이션을 추가한다.
                    3. 필요한 메소드들을 오버라이딩 한다.
                        ● PreHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
                            ○ 컨트롤러에 진입하기 전에 실행되는 메소드
                            ○ 반환 값이 true일 경우 컨트롤러로 진입하고, false일 경우 진입하지 않는다.
                            ○ Object handler는 진입하려는 컨트롤러의 클래스 객체가 담겨있다.
                        
                        ● PostHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)
                            ○ 컨트롤러 진입 후 View가 랜더링 되기 전에 수행되는 메소드
                        
                        ● afterComplete(HttpServletRequest request, HttpServletResponse response, Object object, Exception ex)
                            ○ 컨트롤러 진입 후 view가 랜더링 된 후에 실행되는 메소드
                        
                        ● afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response, Object h)
                            ○ 비동기 요청 시 PostHandle 메소드와 afterCompletion 메소드 대신에 실행되는 메소드
                </pre>
            </li>
            <li>인터셉터 적용하기
                <pre>
                    1. WebMvcConfigurer 인터페이스를 구현한 인터셉터 등록용 클래스를 추가한다. (※ WebMvcConfigurer 인터페이스 : ViewResolver 값을 자동으로 등록해준다.)
                    2. 해당 클래스에 @Configuration 어노테이션을 추가한다.
                    3. 필요한 메소드들을 오버라이딩 한다. (※ InterceptorRegistry 클래스 : 매핑된 인터셉터 목록을 구성하는 데 도움을 주는 클래스)
                        ● public void addInterceptors(InterceptorRegistry registry) : 인터셉터를 등록하는 메소드
                    4. addInterceptors 메소드에서 자신이 생성한 인터셉터 클래스 객체를 등록한다.
                        예시-1)
                            //Lombok의 @RequiredArgsConstructor 추가
                            private final AuthInterceptor authInterceptor;

                            @Override
                            public void addInterceptors(InterceptorRegistry registry) {
                                registry.addInterceptor(authInterceptor)
                                .addPathPatterns("/api/test/*") // 해당 경로에 접근하기 전에 인터셉터가 가로챈다. (필수 X)
                                .excludePathPatterns("/api/service/*"); // 해당 경로는 인터셉터가 가로채지 않는다. (필수 X)
                            }

                        예시-2)
                            private final AuthInterceptor authInterceptor;

                            //MvcConfig는 임의로 만든 인터셉터 등록용 클래스명
                            public MvcConfig(AuthInterceptor authInterceptor) {
                                this.authInterceptor = authInterceptor;
                            }

                            @Override
                            public void addInterceptors(InterceptorRegistry registry) {
                                registry.addInterceptor(authInterceptor)
                                .addPathPatterns("/api/test/*") // 해당 경로에 접근하기 전에 인터셉터가 가로챈다. (필수 X)
                                .excludePathPatterns("/api/service/*"); // 해당 경로는 인터셉터가 가로채지 않는다. (필수 X)
                            }

                    ※ 인터셉터 객체를 @AutoWired로 받을 수도 있지만 그렇게 되면 순환 참조가 일어날 수도 있다.
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="async">
        <header class="note_title">비동기 처리</header>
        <ul>
            <li>비동기 처리를 위한 서비스 Class 만드는 방법
                <pre>
                    1. 비동기 처리를 위한 Class 파일을 만든다.
                    2. 비동기 처리를 시킬 메소드를 만든다.
                        ● 필요 어노테이션 : @Async
                        ● 반환타입 : CompletableFuture
                        ● 리턴형식 : return new AsyncResult(실행할_메소드()).completable(); 또는 
                        ● 예시 )
                            @Async
                            public CompletableFuture run() {
                                return new AsyncResult(helloWolrd()).completable();
                            }
                            public String helloWolrd() {
                                try {
                                    Thread.sleep(1000);
                                } catch (InterruptedException e) {
                                    e.printStackTrace();
                                }
                                return "Hello World !";
                            }

                    ※ 비동기 처리를 진행한 결과를 확인하기 위해 서비스의 메소드는 주로 ListenableFuture나 CompletableFuture 형식으로 결과를 반환한다.
                    ※ 주로 return new AsyncResult(결과물) 형식으로 값을 전달한다.
                    ※ completable() 메소드 : ListenableFuture 객체를 CompletableFuture로 변환해서 리턴한다.
                    ※ AsyncResult의 completable() 메소드는 AsyncResult는 기본적으로 ListenableFuture 인터페이스를 구현하고 있기 때문에
                       해당 결과를 CompletableFuture 형태로 바꾸기 위해 사용한다.
                </pre>
            </li>
            <li>비동기 처리 로직 적용 방법
                <pre>
                    1. @SpringBootApplication 어노테이션이 있는 클래스에 가서 @EnableAsync 어노테이션을 추가한다.
                    2. 컨트롤러에 가서 메소드를 작성한다.
                        ● 예외처리를 반드시 추가한다. (예시 : InterruptedException, ExecutionException 등등)
                    3. 해당 메소드의 return을 비동기 처리를 위해 작성한 Service의 @Async 메소드를 반환한다.
                        예시 )
                            @GetMapping("/api/test/async/listenableFuture")
                            public ListenableFuture<Integer> listenableFuture() throws InterruptedException, ExecutionException {
                                return asyncService.listenableFuture(10000);
                            }
                </pre>
            </li>
            <li>Custom Thread
                <pre>
                    1. Thread 용으로 사용할 Class를 만든다.
                    2. 반환형이 Executor인 메소드를 만든다.
                    3. ThreadPoolTaskExecutor 필드를 만들어 준다.
                    4. ThreadPoolTaskExecutor의 메소드를 통해서 Thread에 대한 설정을 한다.
                    5. 해당 객체를 return 시켜준다.
                    6. 해당 메소드에 @Bean("Thread명")을 추가해준다.

                    ※ @Async 어노테이션의 name 속성에 Thread Bean의 명시해주면 해당 Thread를 사용하도록 할 수 있다.

                    ※ 코드 예시)
                        @Configuration
                        public class AppConfig {
                            @Bean("asyncThread")
                            public Executor asyncThread(){
                                ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
                                executor.setCorePoolSize(10);
                                executor.setMaxPoolSize(100);
                                executor.setQueueCapacity(10);
                                executor.setThreadNamePrefix("Async-");
                                return executor;
                            }
                        }
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="ObjectMapper">
        <header class="note_title">ObjectMapper</header>
        <ul>
            <li>ObjectMapper
                <pre>
                    ● Java 객체를 Json으로 직렬화 하거나 또는 Json 데이터를 Java 객체에 역직렬화 하는 기능을 수행하는 클래스
                    ● 최근 API 서비스가 아니더라도 복잡한 구조의 데이터를 쉽게 서로 주고 받을 수 있게 하기 위해
                      View 영역과 백엔드가 통신을 할 때 Json을 많이 이용하기 때문에 많이 사용하게 된 클래스
                </pre>
            </li>
            <li>사용 조건 (pom.xml의 dependency)
                <pre>
                    ● Spring의 경우
                        &lt;dependency>
                            &lt;groupId>com.fasterxml.jackson.core&lt;/groupId>
                            &lt;artifactId>jackson-databind&lt;/artifactId>
                            &lt;version>2.9.8&lt;/version>
                        </dependency>
                    ● Spring Boot의 경우
                        &lt;dependency>
                            &lt;groupId>org.springframework.boot&lt;/groupId>
                            &lt;artifactId>spring-boot-starter-web&lt;/artifactId>
                        </dependency>
                </pre>
            </li>
            <li>기본 사용 방법
                <pre>
                    ※ ObjectMapper objectMapper = new ObjectMapper();

                    ● Java Object → Json
                        UserVO user = UserVO.builder().name("HongGilDong").age(25).email("hong@naver.com").birthday("19970229").phoneNumber("0001112222").build();
                        String javaObjectToJson = objectMapper.writeValueAsString(user);
                    ● Json → Java Object
                        String jsonString = "{\"name\":\"jsonString\",\"age\":25,\"email\":\"jsonString@naver.com\",\"phoneNumber\":\"0001112222\",\"birthday\":\"19970229\"}";
                        UserVO jsonToJavaObject = objectMapper.readValue(jsonString, UserVO.class);
                    ● JSON 배열을 Java List에 매핑하기
                        String jsonStringA = "{\"name\":\"jsonStringA\",\"age\":25,\"email\":\"jsonStringA@naver.com\",\"phoneNumber\":\"0001112222\",\"birthday\":\"19970229\"}";
                        String jsonStringB = "{\"name\":\"jsonStringB\",\"age\":25,\"email\":\"jsonStringB@naver.com\",\"phoneNumber\":\"0001112222\",\"birthday\":\"19970229\"}";
                        String jsonArray = "["+jsonStringA+","+jsonStringB+"]";
                        List&lt;UserVO> users = objectMapper.readValue(jsonArray, new TypeReference&lt;List&lt;UserVO>>(){});
                    ● JSON 데이터를 Map에 매핑하기
                        String jsonStringForMap = "{\"name\":\"jsonStringForMap\",\"age\":25,\"email\":\"jsonStringForMap@naver.com\",\"phoneNumber\":\"0001112222\",\"birthday\":\"19970229\"}";
                        HashMap&lt;String, Object> map = objectMapper.readValue(jsonStringForMap, new TypeReference&lt;HashMap&lt;String,Object>>(){});

                    ※ 예외사항 (@Builder 어노테이션을 사용하는 경우의 VO)
                        예시)
                            @Getter
                            @Setter
                            @Builder(builderClassName = "UserVOBuilder", toBuilder = true)
                            @JsonDeserialize(builder = UserVO.UserVOBuilder.class)
                            public class UserVO {
                                private String name; //이름
                                private int age; //나이
                                private String email; //이메일
                                private String phoneNumber; //핸드폰번호
                                private String birthday; //생년월일
                                
                                @JsonPOJOBuilder(withPrefix = "") public static class UserVOBuilder { 
                                    
                                }
                            }
                </pre>
            </li>
            <li>추가 사용 방법
                <pre>
                    ※ ObjectMapper objectMapper = new ObjectMapper();

                    ● 역직렬화 실행시 존재하지 않는 필드 무시 설정
                        예시)
                            objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); // 없는 필드로 인한 오류 무시
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="responseEntity">
        <header class="note_title">ResponseEntity</header>
        <ul>
            <li>ResponseEntity Class
                <pre>
                    ● 사용자의 HttpRequest에 대한 응답 데이터를 포함하는 클래스
                    ● HttpEntity를 상속받아서 만들어진 클래스 (HttpEntity = HttpHeaders + HttpBody)
                    ● ResponseEntity = HttpStatus + HttpHeaders + HttpBody + a
                        ○ HttpHeaders : HTTP의 request 또는 response에 대한 부가적인 정보 (예시 : 전달받은 데이터 형식)
                        ○ HttpBody : HTTP의 request 또는 response가 전송하는 데이터 (본문), 존재하지 않는 경우도 있다. (예시 : GET 방식)
                        ○ HttpStatus : 클라이언트의 요청이 성공적으로 처리되었는지 상태를 알려주는 고유의 값 (예시 : 405)
                    ● ResponseEntity 객체가 반환되면 Json이나 Xml 등 다른 형식으로 직렬화가 된다.
                </pre>
            </li>
            <li>전달 형식
                <pre>
                    ● 1번 형태 (한 번에 생성하는 방식)
                        ○ 1-1
                            return new ResponseEntity&lt;반환할 타입>(전달할 body, 전달할 header, HttpStatus.코드명);
                            //예시 : return new ResponseEntity&lt;UserVO>(user, headers , HttpStatus.BAD_REQUEST);
                        ○ 1-2
                            return new ResponseEntity&lt;반환할 타입>(전달할 body, 전달할 header, HttpStatus.valueOf(코드값));
                            //예시 : return new ResponseEntity&lt;UserVO>(user, headers , HttpStatus.valueOf(400));
                    ● 2번 형태 (오류메소드를 사용하여 바로 반환하는 방식)
                        ○ 2-1
                            return ResponseEntity.오류메소드명(객체명); //매개변수가 있는 ok 메소드는 ResponseEntity 형태로 return
                            //예시 : return ResponseEntity.badRequest(user);
                        ○ 2-2
                            return ResponseEntity.오류메소드명().build(); //매개변수가 없는 ok 메소드는 BodyBuilder 형태이기 때문에 build()를 통해서 ResponseEntity 변환 후 return
                            //예시 : return ResponseEntity.ok().build();
                    ● 3번 형태 (각각의 파라미터를 설정해서 개별 설정하는 방식)
                        ○ 사용 예시 )
                            HttpHeaders HttpHeaders변수명 = new HttpHeaders(); //org.springframework.http.HttpHeaders
                            HttpHeaders변수명.set("속성명", "값");

                            VO클래스 vo변수명 = UserVO.builder().필드명("값").build();
                        
                            return ResponseEntity.오류메소드명()
                                    .headers(HttpHeaders변수명)
                                    .body(vo변수명)
                                    .status(HttpStatus.코드명);
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="annotation">
        <header class="note_title">어노테이션 목록</header>
        <ul>
            <li>목록
                <pre>
                    ● @SpringBootApplication
                    ● @JsonProperty
                    ● @JsonNaming
                    ● @JsonInclude
                </pre>
            </li>
            <li>스프링 부트
                <pre>
                    ● @SpringBootApplication : 해당 클래스를 Spring Boot Application으로 설정
                </pre>
            </li>
            <li>컨트롤러 관련 어노테이션
                <pre>
                    ● @RestController
                        ○ 정의 : 해당 클래스를 REST API를 제공하는 컨트롤러로 설정
                        ○ 요약 : @Controller + @ResponseBody
                        ※ 주의점 :
                            @RestController를 붙이게 되면 해당 컨트롤러는 view 페이지를 반환하는게 아닌 응답본문 객체를 반환하는 것이기 때문에
                            Ajax같은 기능에 대한 메소드들이 모여있는 클래스에서 사용하는 것이 좋다.

                    ● @GetMapping : Http Get Method URL 주소 매핑
                    ● @PostMapping : Http Post Method URL 주소 매핑
                    ● @PutMapping : Http Put Method URL 주소 매핑
                    ● @DeleteMapping : Http Delete Method URL 주소 매핑

                    ● @Valid : POJO Java class의 검증
                </pre>
            </li>
            <li>Lombok 어노테이션
                <pre>
                    ● @Data : 종합 선물 세트
                        ○ @Data = @toString  + @EqualsAndHashCode  + @Getter  + @Setter  + @NoArgsConstructor + @RequiredArgsConstructor  + @AllArgsConstructor
                        ○ 효과가 너무 강하여 왠만하면 @Data 어노테이션보다는 필요한 어노테이션만 따로 설정하는 것이 좋다.

                    ● @Getter : getter 메소드를 자동으로 만들어준다. 
                    ● @Setter : setter 메소드를 자동으로 만들어준다.

                    ● @Value : 불변하는 특성을 가진 객체를 만드려고 할 때 사용한다.

                    ● @NoArgsConstructor : 파라미터가 없는 생성자를 생성해준다.
                        ○ final이 붙어있는 경우에는 필드를 초기화 할 수 없기 때문에 생성자를 만들 수가 없어서 에러가 발생한다.
                        ○ final이 붙어있는 경우에는 @NoArgsConstructor(force = true) 옵션을 이용해서 강체로 초기화시켜서 생성자를 만드는 방법을 사용한다.
                        ○ @NonNull 같이 필드에 제약조건이 설정되어 있는 경우, 생성자 내에 null-check 로직이 생성되지 않는다.
                    ● @RequiredArgsConstructor : 추가 작업을 필요로 하는 필드에 대한 생성자를 생성
                        ○ 초기화 되지 않은 모든 final 필드와 @NonNull같은 validator로 마크돼있는 모든 필드들에 대한 생성자를 자동으로 생성해준다.
                        ○ validator 어노테이션이 붙어있는 필드에 대하여 만들어진 생성자는 자동적으로 해당 어노테이션에 대한 검증요소가 추가된다.
                    ● @AllArgsConstructor : 클래스에 존재하는 모든 필드에 대한 생성자를 자동으로 생성해준다.
                        ○ @NoArgsConstructor + @RequiredArgsConstructor
                    ● @Builder : 클래스에 존재하는 모든 필드에 대한 생성자를 자동으로 생성해준다.
                        ○ @AllArgsConstructor 또는 @RequiredArgsConstructor
                        ○ @Builder 이외의 생성자 어노테이션들은 필드를 선언한 순서대로 생성자의 파라미터를 만들기 때문에
                          만약 VO Class에서 두 필드의 선언 순서를 바꿨는데 두 필드가 자료형까지 같다면 오류가 발생하지 않기 때문에
                          추후에 문제가 발생해도 모를 확률이 크기때문에 @Builder를 사용하는 것이 좋다.
                        ○ 기본 사용 예시
                            UserVO tempUser
                                = UserVO.builder()
                                    .name("홍길동")
                                    .age(25)
                                    .email("hong@naver.com")
                                    .phoneNumber("0001112222")
                                    .birthday("19970229")
                                    .build();
                        ○ @Builder(toBuilder = true) 사용 예시 : builder 패턴으로 생성된 객체의 일부 값을 변경한 새로운 객체 생성
                            UserVO userA
                            = UserVO.builder()
                                .name("A")
                                .age(25)
                                .email("hong@naver.com")
                                .phoneNumber("0001112222")
                                .birthday("19970229")
                                .build();

                            //userA에서 name/age 값만 변경된 새로운 객체를 생성 
                            BuilderVO b2 = b.toBuilder().name("B").age(24).build();
                        ○ @Builder.Default 사용 예시 :
                            private String name; //기본 값 null
                            @Builder.Default private String job="programmer"; //기본 값 부여
                        ○ @Singular 옵션 사용 예시 :
                            //vo
                            @Singular("hobbyList") private List&lt;String> hobbyList;
                            //생성 영역
                            UserVO userC
                            = UserVO..builder() .hobbyList("game") .hobbyList("read book") .hobbyList("listen music") .build();


                    ● @toString : 해당 VO Class의 모든 필드를 출력하는 toString 메소드를 생성한다.
                    ● @EqualsAndHashCode - hashcode와 equals 메소드를 생성한다.
                        ○ 불변 클래스를 제외하고는 아무 파라미터 없는 @EqualsAndHashCode 어노테이션은 사용하지 않는 것이 좋다.
                        ○ 항상 @EqualsAndHashCode(of={“필드명시”}) 형태로 동등성 비교에 필요한 필드를 명시하는 형태로 사용한다.

                    ● @Log / @Slf4j (★) / @Log4j2 : log 기능을 바로 사용해줄 수 있게 해준다.
                    ● @NonNull : null 값 체크
                    ● @Cleanup : I/O 작업이나 JDBC 작업시 try-catch-finally문의 finally에서 close()를 사용해야 하던 번거로움을 줄여준다.
                        예시) @Cleanup Connection con = DriverManager.getConnection(url, user, password);
                    ● @SneakyThrows(예외오류명.class) : throws나 try-catch문의 catch를 통한 번거로운 예외 처리 생략가능
                    ● @Synchronized : 동기화

                    ※ Lombok 설치 방법
                        1. pom.xml에 dependency 추가
                            &lt;dependency>
                                &lt;groupId>org.projectlombok&lt;/groupId>
                                &lt;artifactId>lombok&lt;/artifactId>
                                &lt;version>1.18.16&lt;/version>
                                &lt;scope>provided&lt;/scope>
                            &lt;/dependency>
                        2-A-1. cmd를 켜서 cd C:\Users\사용자명\.m2\repository\org\projectlombok\lombok\lombok버전 실행
                        2-A-2. java -jar lombok.jar 실행 (버전이 있는 경우 java -jar lombok-1.18.16.jar)
                        2-B-1. 파일 탐색기를 열고 C:\Users\사용자명\.m2\repository\org\projectlombok\lombok\lombok로 이동
                        2-B-2. lombok.jar 파일 실행
                        3. IDEs 목록에 사용하는 STS(eclipse)를 선택 (안 보이면 Specify location 버튼으로 찾기)
                        4. Install / Update 클릭
                        5. Install Successful이 출력되면 성공 (Quit Installer는 단순 종료 버튼)

                    ※ Lombok 어노테이션 추가 위치
                        ● 클래스 위
                        ● 필드 위

                    ※ @Getter / @Setter에 필드를 포함시키지 않는 방법
                        ● @Geeter(AccessLevel.None)
                        ● @Setter(AccessLevel.None)

                    ※ 생성자 어노테이션을 고유 이름으로 만들기
                       1. 해당 VO Class에 생성자 어노테이션을 추가한다.
                       2. 해당 어노테이션에 staticName="원하는 이름" 옵션을 추가한다.
                       3. 해당 Class에 대한 생성자는 private로 만들어진다.
                       4. private로 만들어진 생성자를 return 시키는 public static 생성자가 만들어진다. (생성자명은 옵션에 명시한 이름)

                    ※ 주의점
                        ● static 필드에도 @Getter / @Setter 적용이 가능하다.
                        ● enum에도 @Getter를 사용할 수 있다.
                        ● enum에는 @Setter를 사용할 수 없다.
                        ● 생성자 어노테이션에서 static 필드는 제외된다.
                        ● 생성자 어노테이션 사용 시 생성자의 파라미터의 순서는 해당 VO Class에서 필드를 선언한 순서와 같다. (주의 필요)
                        ● 생성자 어노테이션 사용시 기본값은 public이지만 필요로 따라서 접근 제한자를 설정해야 한다.
                        ● 생성자 어노테이션도 (access =AccessLevel.PROTECTED)처럼 기본 접근 제한자를 선택할 수 있는 옵션이 존재한다.
                        ● 왜인지는 모르겠는데 @Builder를 사용할 때 커스텀 어노테이션이 있으니까 오류가 생긴다.
                </pre>
            </li>
            <li>Custom Annotation
                <pre>
                   1. 어노테이션용 패키지를 만든다.
                   2. 해당 패키지에서 어노테이션 파일을 만든다. (New에 보면 어노테이션이 있다.)
                   3. 어노테이션 제작 시 필요한 항목들을 선택해서 만들거나 아니면 아래의 기본적인 값들을 복사 및 붙여넣기 한다.
                        기초 import 목록 )
                            import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
                            import static java.lang.annotation.ElementType.CONSTRUCTOR;
                            import static java.lang.annotation.ElementType.FIELD;
                            import static java.lang.annotation.ElementType.METHOD;
                            import static java.lang.annotation.ElementType.PARAMETER;
                            import static java.lang.annotation.ElementType.TYPE_USE;
                            import static java.lang.annotation.RetentionPolicy.RUNTIME;
                            
                            import java.lang.annotation.Documented;
                            import java.lang.annotation.Retention;
                            import java.lang.annotation.Target;
                            
                            import javax.validation.Constraint;
                            import javax.validation.Payload;
                        기초 어노테이션 목록 )
                            @Documented
                            @Constraint(validatedBy = { })
                            @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
                            @Retention(RUNTIME)
                        기초 속성 목록 )
                            String message() default "{javax.validation.constraints.Email.message}";
                            Class&lt;?>[] groups() default { };
                            Class&lt;? extends Payload>[] payload() default { };
                            String regexp() default ".*";
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="reference">
        <header class="note_title">참조 목록</header>
        <ul>
            <li>Talend API Tester
                <pre>
                    ● 요청에 대한 테스트를 진행할 수 있는 크롬 앱
                    ● 크롬 앱스토어에서 설치 가능
                    ● 비슷한 프로그램 : 포스트맨
                </pre>
            </li>
        </ul>
    </section>

    <br>

    <section id="xxx">
        <header class="note_title">xxx</header>
        <ul>
            <li>xxx
                <pre>
                    ● xxx
                </pre>
            </li>
        </ul>
    </section>

    <div id="remote">
        <section id="remote_setcion">
            <select id="remote_menu">
                <option value="intro">스프링 부트</option>
                <option value="validation">유효성 검사</option>
                <option value="exception">예외 처리</option>
                <option value="filter">필터</option>
                <option value="interceptor">인터셉터</option>
                <option value="async">비동기 처리</option>
                <option value="ObjectMapper">ObjectMapper</option>
                <option value="responseEntity">ResponseEntity</option>
                <option value="annotation">어노테이션 목록</option>
                <option value="reference">참조 목록</option>
            </select>
        </section>
    </div>

    <!-- 모달 영역 시작 -->
    <div id="xxx" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <span class="modal_title">xxx</span>
            <div class="modal_content">
                <p style="margin-left: 30px;">
                    xxx
                </p>
            </div>
        </div>
    </div>
    <!-- 모달 영역 종료 -->

    <script src="./remote.js"></script>
</body>
</html>