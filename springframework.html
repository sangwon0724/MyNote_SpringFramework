<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>이론 공부</title>
    <link rel="stylesheet" href="./css/index.css" />
</head>
<body>
    <section id="intro">
        <span>
            <bold>스프링 프레임워크</bold>
        </span>
        <span>기본 소개
            <pre>
                ● 핵심 기술 : 스프링 DI 컨테이너, AOP, 이벤트, 기타
                ● 웹 기술 : 스프링 MVC, 스프링 WebFlux
                ● 데이터 접근 기술 : 트랜잭션, JDBC, ORM 지원, XML 지원
                ● 기술 통합 : 캐시, 이메일, 원격접근, 스케쥴링
                ● 테스트 : 스프링 기반 테스트 지원
                ● 언어 : 코틀린, 그루비
            </pre>
        </span>
        <span>스프링의 핵심
            <pre>
                ● 스프링은 자바 언어 기반의 프레임워크
                ● 자바 언어의 가장 큰 특징 - 객체 지향 언어
                ● 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
                ● 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크
            </pre>
        </span>
    </section>

    <br>

    <section id="base">
        <span>
            <bold>이론</bold>
        </span>
        <span>xxx
            <pre>
                ● 
            </pre>
        </span>
    </section>

    <br>

    <section id="bean">
        <span>
            <bold>스프링 빈</bold>
        </span>
        <span>스프링 컨테이너
            <pre>
                ● 스프링 컨테이너 : 주입을 이용해서 객체를 관리하는 컨테이너
                ● 스프링 컨테이너의 역할 : 빈의 생성과 관계, 사용, 생명 주기등을 관리
                ● 스프링 컨테이너 사용 이유 : 종속객체 주입을 이용하여 애플리케이션을 구성하는 컴포넌트들을 관리한다.
                ● 스프링 컨테이너 종류
                    (1) 빈 팩토리 : DI의 기본사항을 제공하는 가장 단순한 컨테이너 팩토리 디자인 패턴을 구현한 것
                        ○ 빈을 생성하고 분배하는 책임을 지는 클래스
                        ○ 빈의 정의는 반드시 로딩한다.
                        ○ 빈 자체가 필요하게 되기 전까지는 인스턴스화를 하지 않는다. (lazy loading, 게으른 호출)
                    (2) 어플리케이션 컨텍스트 : 빈 팩토리와 유사한 하지만 좀 더 많은 기능을 제공하는 컨테이너
                        ○ 국제화가 지원되는 텍스트 메시지를 관리해준다.
                        ○ 이미지같은 파일 자원을 로드할 수 있는 포괄적인 방법을 제공해준다.
                        ○ 리너스로 등록된 빈에게 이벤트 발생을 알려준다.
                        ○ 대부분의 어플리케이션에서는 빈 팩토리보다 어플리케이션 컨텍스트를 사용하는 것이 좋다.
            </pre>
        </span>
        <span>빈 팩토리 사용법
            <pre>
                ● getBean()이 호출되면, 팩토리는 의존성 주입을 이용해 빈을 인스턴스화 하고 빈의 특성을 설정하기 시작한다.

                코드)
                
                    BeanFactory BF = new XmlBeanFactory(new FileInputStream("beanFactoryTest.xml"));

                    testBean testbean = (testBean) BF.getBean("testbean");

            </pre>
        </span>
        <span>어플리케이션 컨텍스트 사용법
            <pre>
                ● 어플리케이션 컨텍스트의 구현체 종류
                    (1) ClassPathXmlApplicationContext : 클래스패스에 위치한 xml 파일에서 컨텐스트 정의 내용을 읽어들인다.
                    (2) FileSystemxmlApplicationContext : 파일 경로로 지정된 xml 파일에서 컨텐스트 정의 내용을 읽어들인다.
                    (3) XmlWebApplicationContext : 웹 어플리케이션에 포함된 xml 파일에서 컨텐스트 정의 내용을 읽어들인다.

                    코드)
                        ApplicationContext AC = new ClassPathXmlApplicationContext("context/contextBean.xml");

                        testBean testbean = AC.getBean("testbean");
            </pre>
        </span>
        <span>빈 팩토리와 어플리케이션 컨텍스트의 차이점
            <pre>
                ● 빈 팩토리 : 처음으로 getBean()이 호출된 시점에서야 해당 빈을 생성
                ● 애플리케이션 컨텍스트 : 컨텍스트 초기화 시점에 모든 싱글톤 빈을 미리 빈을 생성해 놓아 빈이 필요할 때 즉시 사용할 수 있도록 보장
            </pre>
        </span>
        <span>xml 파일을 통한 빈 등록하기
            <pre>
                ● bean 태그
                    ○ id : 등록하는 빈의 고유 명칭
                    ○ class : 등록하는 빈의 실제 형식
                ● property 태그 (Setter를 통한 의존 관계가 있는 Bean 주입시 사용)
                    ○ name : 지정할 속성의 이름
                    ○ value : 지정할 속성의 값
                    ○ ref : 지정할 속성이 참조하는 빈의 id
                ● constructor-arg 태그 (생성자를 통한 의존 관계가 있는 Bean 주입시 사용)
                    ○ ref : 지정할 속성이 참조하는 빈의 id
                ● qualifier 태그
                    ○ value : @Qualifier("명칭")에서 사용할 이름
                코드)
                    &lt;bean id="beanTest" class="com.example.practice.beanTest">
                        &lt;property name="ref" ref="refTest"/>
                        &lt;property name="whatever" value="whatever"/>
                    &lt;/bean>

                    &lt;bean id="refTest" class="com.example.practice.refTest"/>

                    &lt;bean id="qualifierTest1" class="com.example.practice.qualifierTest">
                        &lt;qualifier value="target"/> 
                    &lt;/bean>
                    &lt;bean id="qualifierTest2" class="com.example.practice.qualifierTest"/>
            </pre>
        </span>
    </section>

    <br>

    <section id="singleton">
        <span>
            <bold>싱글톤 패턴</bold>
        </span>
        <span>
            <pre>
                ● 
            </pre>
        </span>
    </section>

    <br>

    <section id="component">
        <span>
            <bold>컴포넌트 스캔</bold>
        </span>
        <span>
            <pre>
                ● 
            </pre>
        </span>
    </section>

    <br>

    <section id="IOC">
        <span>
            <bold>스프링 3대 요소 - 제어 역전 (IOC)</bold>
        </span>
        <span>
            <pre>
                ● 제어 역전 (Inversion of Control)
                    ○ 객체의 생성에서부터 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀌는 것
                    ○ 스프링 컨테이너가 필요에 따라 개발자 대신 빈들을 관리해주는 행위 (생명 주기 관리 : 생성 → 의존성 설정 → 초기화 → 소멸)
                ● 제어 역전의 등장 배경
                    ○ 기존의 객체 관리는 개발자가 직접 했어야 했다. (new, 의존성 맺기, 초기화 등등)
                    ○ 번거로운 객체의 생명주기 관리를 대신 해줄 무언가가 필요했다.
                ● 제어 역전 방법
                    ○ xml 파일을 통해서 빈을 등록
                    ○ 어노테이션을 통해서 빈을 등록
                ● 제어 역전의 장점
                    ○ 개발자는 객체 관리에 덜 신경쓸 수 있게 되어 다른 부분에 더 집중할 수 있게 됨
                    ○ 약한 결합을 이용하여 객체 간 의존관계를 쉽게 변경할 수 있음
                    ○ 코드의 재사용성과 유지보수성을 높인다. 
            </pre>
        </span>
    </section>

    <br>

    <section id="DI">
        <span>
            <bold>스프링 3대 요소 - 의존성 주입 (DI)</bold>
        </span>
        <span>기본적인 사용법
            <pre>
                ● 의존성 주입 (Dependency Injection) : 어떤 객체에 스프링 컨테이너가 또 다른 객체와 의존성을 맺어주는 행위

                코드)
                    public class TestA{

                    }

                    @Component
                    public class TestB{
                        
                    }

                    public static void main(String[] args) {
                        TestA testA = new TestA();

                        @Autowired
                        TestB testB;
                    }
            </pre>
        </span>
        <span>어노테이션의 종류에 따른 다양한 의존성 주입 방법
            <pre>
                ● @Autowired : 해당하는 타입의 객체를 찾아서 자동으로 할당하는 어노테이션
                    ○ 생성자, 메소드, 멤버변수 위에 모두 사용 가능
                    ○ 스프링 컨테이너는 @Autowired가 붙어 있는 것을 확인하는 순간 해당 변수의 타입을 체크하고 그 타입의 객체가 메모리 상에 존재하면 해당 변수에 객체를 대입한다.
                    ○ 만약 @Autowired를 선언한 것에 대한 객체가 존재하지 않는 타입이라면 NoSuchBeanDefinitionException이 발생한다.
                    ○ 탐색 순서 : 타입 -> 이름 -> @Qualifier -> 실패
                    ○ 만약 찾는 빈 객체가 없는 경우 발생하는 예외를 피하고 싶다면 @Autowired(required=false)처럼 쓰면 된다.
                    ○ @Autowired(required=false)를 통해 찾는 객체가 없는 경우에 대한 null 처리 소스도 작성해야 한다.

                ● @Qualifier : @Autowired와 함께 사용하는 어노테이션
                    ○ 특정 객체의 이름을 사용하여 의존성 주입할 때 사용
                    ○ 인터페이스에 대해 @Autowired가 실행됬을 때, 적절한 빈을 컨테이나가 찾지 못하는 경우에 사용한다.
                    ○ @Qualifier를 사용하여 직접 빈의 이름을 지정하여 컨테이너가 어떤 객체를 주입할지 선택할 수 있게 해준다.
                    ○ 빈이 등록된 xml 파일에서 미리 qualifier 태그를 통해 지정을 해둬야 한다.
                    ○ 빈 자체의 id가 아닌 qualifier 태그에 명시한 value를 통해 이름을 지정한다.
                    ○ @Autowired를 먼저 사용한 후 @Qualifier("명칭")을 사용하면 된다.

                ● @Inject : 해당하는 타입의 객체를 찾아서 자동으로 할당하는 어노테이션
                    ○ 생성자, 메소드, 멤버변수 위에 모두 사용 가능
                    ○ 탐색 순서 : 타입 -> @Named-> 이름 -> 실패

                ● @Named : @Inject 함께 사용하는 어노테이션
                    ○ 특정 객체의 id를 사용하여 의존성 주입할 때 사용
                    ○ @Inject 먼저 사용한 후 @Named("id명")을 사용하면 된다.

                ● @Resource : 주입하려고 하는 객체의 id가 일치하는 객체를 자동으로 주입한다.
                    ○ 메소드, 멤버변수 위에 사용 가능
                    ○ 사실상 @Autowired + @Qualifier
                    ○ 탐색 순서 : 이름 -> 타입 -> @Qualifier -> 실패
                    ○ @Resource나 @Resource(name="등록된 빈의 id")로 사용한다.
                    ○ &lt;context:annotation-config/>를 xml 파일에 추가해야지 사용할수 있다.
            </pre>
        </span>
    </section>

    <br>

    <section id="AOP">
        <span>
            <bold>스프링 3대 요소 - 관점 지향 프로그래밍 (AOP)</bold>
        </span>
        <span>
            <pre>
                ● 
            </pre>
        </span>
    </section>

    <br>

    <section id="annotation">
        <span>
            <bold>어노테이션</bold>
        </span>
        <span>어노테이션 목록
            <pre>
                ● 
            </pre>
        </span>
        <span>어노테이션 생성하기
            <pre>
                ● 
            </pre>
        </span>
    </section>

    <div id="remote">
        <section id="remote_setcion">
            <select id="remote_menu">
                <option value="intro">스프링 프레임워크</option>
                <option value="base">이론</option>
                <option value="bean">스프링 빈</option>
                <option value="singleton">싱글톤 패턴</option>
                <option value="component">컴포넌트 스캔</option>
                <option value="IOC">제어 역전 (IOC)</option>
                <option value="DI">의존성 주입 (DI)</option>
                <option value="AOP">관점 지향 프로그래밍 (AOP)</option>
                <option value="annotation">어노테이션</option>
            </select>
        </section>
    </div>

    <script src="./remote.js"></script>
</body>
</html>