<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>이론 공부</title>
    <link rel="stylesheet" href="./css/index.css" />
</head>
<body>
    <section id="intro">
        <span>
            <bold>스프링 프레임워크</bold>
        </span>
        <span>기본 소개
            <pre>
                ● 핵심 기술 : 스프링 DI 컨테이너, AOP, 이벤트, 기타
                ● 웹 기술 : 스프링 MVC, 스프링 WebFlux
                ● 데이터 접근 기술 : 트랜잭션, JDBC, ORM 지원, XML 지원
                ● 기술 통합 : 캐시, 이메일, 원격접근, 스케쥴링
                ● 테스트 : 스프링 기반 테스트 지원
                ● 언어 : 코틀린, 그루비
            </pre>
        </span>
        <span>스프링의 핵심
            <pre>
                ● 스프링은 자바 언어 기반의 프레임워크
                ● 자바 언어의 가장 큰 특징 - 객체 지향 언어
                ● 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
                ● 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크
            </pre>
        </span>
    </section>

    <br>

    <section id="base">
        <span>
            <bold>이론</bold>
        </span>
        <span>xxx
            <pre>
                ● 
            </pre>
        </span>
    </section>

    <br>

    <section id="bean">
        <span>
            <bold>스프링 빈</bold>
        </span>
        <span>스프링 컨테이너
            <pre>
                ● 스프링 컨테이너 : 주입을 이용해서 객체를 관리하는 컨테이너
                ● 스프링 컨테이너의 역할 : 빈의 생성과 관계, 사용, 생명 주기등을 관리
                ● 스프링 컨테이너 사용 이유 : 종속객체 주입을 이용하여 애플리케이션을 구성하는 컴포넌트들을 관리한다.
                ● 스프링 컨테이너 종류
                    (1) 빈 팩토리 : DI의 기본사항을 제공하는 가장 단순한 컨테이너 팩토리 디자인 패턴을 구현한 것
                        ○ 빈을 생성하고 분배하는 책임을 지는 클래스
                        ○ 빈의 정의는 반드시 로딩한다.
                        ○ 빈 자체가 필요하게 되기 전까지는 인스턴스화를 하지 않는다. (lazy loading, 게으른 호출)
                    (2) 어플리케이션 컨텍스트 : 빈 팩토리와 유사한 하지만 좀 더 많은 기능을 제공하는 컨테이너
                        ○ 국제화가 지원되는 텍스트 메시지를 관리해준다.
                        ○ 이미지같은 파일 자원을 로드할 수 있는 포괄적인 방법을 제공해준다.
                        ○ 리너스로 등록된 빈에게 이벤트 발생을 알려준다.
                        ○ 대부분의 어플리케이션에서는 빈 팩토리보다 어플리케이션 컨텍스트를 사용하는 것이 좋다.
            </pre>
        </span>
        <span>빈 팩토리 사용법
            <pre>
                ● getBean()이 호출되면, 팩토리는 의존성 주입을 이용해 빈을 인스턴스화 하고 빈의 특성을 설정하기 시작한다.

                코드)
                
                    BeanFactory BF = new XmlBeanFactory(new FileInputStream("beanFactoryTest.xml"));

                    testBean testbean = (testBean) BF.getBean("testbean");

            </pre>
        </span>
        <span>어플리케이션 컨텍스트 사용법
            <pre>
                ● 어플리케이션 컨텍스트의 구현체 종류
                    (1) ClassPathXmlApplicationContext : 클래스패스에 위치한 xml 파일에서 컨텐스트 정의 내용을 읽어들인다.
                    (2) FileSystemxmlApplicationContext : 파일 경로로 지정된 xml 파일에서 컨텐스트 정의 내용을 읽어들인다.
                    (3) XmlWebApplicationContext : 웹 어플리케이션에 포함된 xml 파일에서 컨텐스트 정의 내용을 읽어들인다.

                    코드)
                        ApplicationContext AC = new ClassPathXmlApplicationContext("context/contextBean.xml");

                        testBean testbean = AC.getBean("testbean");
            </pre>
        </span>
        <span>빈 팩토리와 어플리케이션 컨텍스트의 차이점
            <pre>
                ● 빈 팩토리 : 처음으로 getBean()이 호출된 시점에서야 해당 빈을 생성
                ● 애플리케이션 컨텍스트 : 컨텍스트 초기화 시점에 모든 싱글톤 빈을 미리 빈을 생성해 놓아 빈이 필요할 때 즉시 사용할 수 있도록 보장
            </pre>
        </span>
        <span>xml 파일을 통한 빈 등록하기
            <pre>
                ● bean 태그
                    ○ id : 등록하는 빈의 고유 명칭
                    ○ class : 등록하는 빈의 실제 형식
                ● property 태그 (Setter를 통한 의존 관계가 있는 Bean 주입시 사용)
                    ○ name : 지정할 속성의 이름
                    ○ value : 지정할 속성의 값
                    ○ ref : 지정할 속성이 참조하는 빈의 id
                ● constructor-arg 태그 (생성자를 통한 의존 관계가 있는 Bean 주입시 사용)
                    ○ ref : 지정할 속성이 참조하는 빈의 id
                ● qualifier 태그
                    ○ value : @Qualifier("명칭")에서 사용할 이름
                코드)
                    &lt;bean id="beanTest" class="com.example.practice.beanTest">
                        &lt;property name="ref" ref="refTest"/>
                        &lt;property name="whatever" value="whatever"/>
                    &lt;/bean>

                    &lt;bean id="refTest" class="com.example.practice.refTest"/>

                    &lt;bean id="qualifierTest1" class="com.example.practice.qualifierTest">
                        &lt;qualifier value="target"/> 
                    &lt;/bean>
                    &lt;bean id="qualifierTest2" class="com.example.practice.qualifierTest"/>
            </pre>
        </span>
    </section>

    <br>

    <section id="beanLifeCycle">
        <span>
            <bold>빈 생명주기</bold>
        </span>
        <span>
            <pre>
                ● 기본적인 생명주기 :
                    생성 → 빈 설정 (초기화) → 사용 → 소멸

                ● 기초적인 사용방법 :
                    코드)
                    AnnotationConfigApplicationContext test = new AnnotationConfigApplicationContext(AnnotationBeanTest.class);
                    //ApplicationContext test = new ClassPathXmlApplicationContext("applicationContextTest.xml");

                    //빈 생성하기
                    test.register();
                    
                    //빈 설정하기
                    test.refresh();

                    //빈 사용하기
                    whatever what = (whatever)test.getBean("what");
                    
                    //빈을 직접 소멸시키기
                    test.close();

                    //JVM 소멸시 자동으로 소멸시키는 방법
                    test.registerShutdownHook();
            </pre>
        </span>
        <span>기본적인 전제조건
            <pre>
                ● 빈에 관련된 메소드를 정의한 클래스에는 @Configuration 어노테이션을 추가해야 한다.
            </pre>
        </span>
        <span>빈 생명주기 사용방법 1 : 인터페이스 활용하기
            <pre>
                ● 빈 초기화 하기
                    ○ InitializingBean 인터페이스를 활용한다.
                    ○ afterPropertiesSet()가 초기화를 지원한다.
                    ○ 빈이 생성되면 afterPropertiesSet()가 자동으로 실행되어 빈이 초기화된다.

                ● 빈 소멸하기
                    ○ DisposableBean 인터페이스를 활용한다.
                    ○ destroy() 메소드가 소멸을 지원한다.
                    ○ 빈의 사용이 완료되면 destroy() 메소드가 자동으로 실행되어 빈이 소멸된다.
                
                ● 인터페이스를 활용하는 방법의 장단점
                    ○ 스프링 전용 인터페이스에 해당 코드가 의존한다.
                    ○ 초기화, 소멸 메소드의 이름을 변경할 수 없다.
                    ○ 내가 코드를 고칠수 없는 외부 라이브러리에 적용할 수 없다.
                    ○ 이 방법은 스프링 초창기에 나온 방법이라서 지금은 거의 사용하지 않는 방법이다.
            </pre>
        </span>
        <span>빈 생명주기 사용방법 2 : 사용자 정의 메소드 활용하기
            <pre>
                ● 빈 초기화 하기 + 소멸하기
                    ○ 해당 클래스에서 빈을 초기화할 때의 메소드와 소멸할 때의 메소드를 직접 정의한다.

                ● 사용방법
                    ○ BeanLifeCycle이라는 이름의 빈 메소드를 정의한 클래스를 생성했다고 가정한다.
                    ○ 해당 클래스인 BeanLifeCycle을 사용하는 코드의 위쪽에 @Bean 어노테이션을 추가한다.
                    ○ @Bean 어노테이션의 속성으로 initMethod와 destroyMethod를 추가한다.
                    ○ 각 속성의 값은 빈 관련 메소드를 작성했던 클래스인 BeanLifeCycle에서 자신이 작성한 각각의 빈 초기화 메소드와 빈 소멸 메소드의 이름을 작성한다.
                
                ● 사용자 정의 메소드 활용하는 방법의 특징
                    ○ 메소드의 이름을 자유롭게 줄 수 있다.
                    ○ 스프링 빈이 스프링 코드에 의존하지 않는다.
                    ○ 코드가 아니라 설정 정보를 사용하기 때문에
                      코드를 고칠 수 없는 외부 라이브러리에도 적용시킬 수 있다.

                ● @Bean 어노테이션의 destroyMethod 속성의 기본 값
                    ○ @Bean 어노테이션의 destroyMethod 속성은 기본 값이 (inferred)로 등록되어 있다.
                    ○ (inferred)는 close와 shutdown이라는 메소드를 자동으로 호출해서 빈을 소멸시켜 준다.
                    ○ 따라서 해당 방법을 이용시에는 빈 소멸메소드를 따로 만들지 않아도 잘 작동한다.
            </pre>
        </span>
        <span>빈 생명주기 사용방법 3 : 어노테이션 활용하기
            <pre>
                ● 빈 초기화 하기
                    ○ 본인이 작성한 빈 초기화 메소드에 @PostConstruct 어노테이션을 추가한다.

                ● 빈 소멸 하기
                    ○ 본인이 작성한 빈 소멸 메소드에 @PreDestroy 어노테이션을 추가한다.

                ● 사용하기
                    ○ BeanLifeCycle이라는 이름의 빈 메소드를 정의한 클래스를 생성했다고 가정한다.
                    ○ 해당 클래스인 BeanLifeCycle을 사용하는 코드의 위쪽에 @Bean 어노테이션을 추가한다.
                    ○ 해당 방법에서는 @Bean 어노테이션에 속성을 추가하지 않아도 된다.
                
                ● 어노테이션을 사용하는 방법의 특징
                    ○ 어노테이션만 붙이면 되니 매우 간편하다.
                    ○ 스프링에 종속적인 기술이아는 자바 표준 기술이기 떄문에 스프링이 아닌 다른 컨테이너에서도 잘 작동한다.
                    ○ 컴포넌트 스캔과 잘 어울린다.
                    ○ 외부 라이브러리에는 적용하지 못한다.
                    ○ 외부 라이브러이를 초기화나 소멸시키고 싶을 때에는 @Bean의 기능을 사용하면 된다.
                    ○ 최신 스프링에서 가장 권장하는 방법이다.
            </pre>
        </span>
    </section>

    <br>

    <section id="beanScope">
        <span>
            <bold>빈 스코프</bold>
        </span>
        <span>
            <pre>
                ● 정의 : 빈이 존재할 수 있는 범위

                ● 빈 스코프의 종류
                    ○ 싱글톤 :
                        기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다

                    ○ 프로토 타입 :
                        스프링 컨테이너가 프로토타입의 빈의 생성과 의존관계 주입까지만 관여하고
                        더는 빈에 관련된 작업들에 관여하지 않는 매우 짧은 범위의 스코프

                    ○ 웹 관련 스코프
                        ▶ request : 웹 요청이 들어오고 나갈때 까지 유지되는 스코프
                        ▶ session : 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프
                        ▶ application : 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프
                        ▶ websocket: 웹 소켓과 동일한 생명주기를 가지는 스코프
            </pre>
        </span>
    </section>

    <br>

    <section id="singleton">
        <span>
            <bold>빈 스코프 - 싱글톤 스코프</bold>
        </span>
        <span>싱글톤 스코프의 특징
            <pre>
                ● 스코프를 명시적으로 지정하지 않으면 설정되는 기본 스코프
                ● 빈 스코프를 싱글톤으로 사용하면 빈을 각각의 다른 객체로 생성해도 같은 것을 가리키게 된다.
                ● 싱글톤 빈은 스프링 컨테이너에서 한 번 생성된다.
                ● 스프링 컨테이너가 사라질 떄 빈도 사라진다.
                ● ApplicationContext 초기 구동시 인스턴스 생성된다.
                ● 생성된 인스턴스는 single beans cache에 저장된다.
                ● 해당 빈에 대한 요청과 참조가 있으면 캐시된 객체를 반환한다.
            </pre>
        </span>
        <span>싱글톤 스코프의 사용 방법 (스코프의 기본 값이 싱글톤이기 때문에 생략해도 상관없다.)
            <pre>
                ● xml을 통한 사용방법
                    &lt;bean id="test" scope="singleton">&lt;/bean>

                ● 어노테이션을 통한 사용방법
                    @Scope("singleton")
            </pre>
        </span>
        <span>싱글톤 패턴
            <pre>
                ● 클래스의 인스턴스가 1개만 생성되도록 하는 디자인 패턴
                ● private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막아야 한다
            </pre>
        </span>
        <span>싱글톤 패턴의 문제점
            <pre>
                ● 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
                ● 의존관계상 클라이언트가 구체 클래스에 의존한다. DIP를 위반한다.
                ● 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.
                ● 테스트하기 어렵다.
                ● 내부 속성을 변경하거나 초기화 하기 어렵다.
                ● private 생성자로 자식 클래스를 만들기 어렵다.
                ● 결론적으로 유연성이 떨어진다.
                ● 안티패턴으로 불리기도 한다.
            </pre>
        </span>
        <span>싱글톤 컨테이너
            <pre>
                ● 스프링 컨테이너는 기본적으로 객체 인스턴스를 싱글톤으로 관리한다.
                ● 스프링 컨테이너는 기본적으로 빈 스코프가 싱글톤이기 때문에 객체를 하나만 생성해서 관리한다.
                ● 스프링 컨테이너는 싱글턴 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다.
                ● 싱글톤 패턴을 위한 코드를 간결해질 수 있게 해준다.
                ● DIP, OCP, 테스트, private 생성자로 부터 자유롭게 싱글톤을 사용할 수 있다.

                ● 싱글톤 레지스트리 : 싱글톤 객체를 생성하고 관리하는 기능
            </pre>
        </span>
        <span>싱글톤 방식의 주의점
            <pre>
                ● 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에
                  싱글톤 객체는 상태를 유지하게 설계하면 안된다.
                ● 특정 클라이언트에 의존적인 필드가 존재하면 안된다.
                ● 특정 클라이언트가 값을 변경할 수 있는 필드가 존재하면 안된다.
                ● 가급적 읽기만 가능해야 한다.
                ● 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.
                ● 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다.
                    예시) 개인 정보
            </pre>
        </span>
        <span>싱글톤 방식을 위한 @Configuration 어노테이션
            <pre>
                ● @Bean 어노테이션만 사용해도 스프링 빈으로 등록되지만, 싱글톤을 보장하지 않는다.
            </pre>
        </span>
    </section>

    <br>

    <section id="prototype">
        <span>
            <bold>빈 스코프 - 프로토타입 스코프</bold>
        </span>
        <span>정의
            <pre>
                ● 빈을 조회했을 때 스프링 컨테이너가 빈을 생성하고 필요한 의존관계를 주입한 다음에
                  생성한 프로토타입 빈을 클라이언트에 반환한 다음에 더 이상 빈을 관리하지 않는 빈 스코프의 종류 중 하나
            </pre>
        </span>
        <span>사용방법
            <pre>
                ● 클래스에 @Scope("prototype") 어노테이션을 추가한다.
            </pre>
        </span>
        <span>프로토타입 빈의 특징
            <pre>
                ● 스프링 컨테이너에 요청할 때 마다 새로 생성된다.
                ● 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입 그리고 초기화까지만 관여한다.
                ● 종료 메서드가 호출되지 않는다.
                ● 프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야 한다.
                ● 프로토타입 빈은 종료 메서드에 대한 호출을 클라이언트가 직접 해야한다
            </pre>
        </span>
    </section>

    <br>

    <section id="component">
        <span>
            <bold>컴포넌트 스캔</bold>
        </span>
        <span>정의
            <pre>
                ● 컴포넌트 스캔 :
                    스프링에서 제공하는 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 기능
            </pre>
        </span>
        <span>컴포넌트 스캔 사용방법
            <pre>
                ● 기본적인 사용방법
                    ○ 클래스에 @ComponentScan 어노테이션을 추가한다.
                    ○ 빈으로 등록할 대상에 @Component 어노테이션을 추가한다.

                ● 특정 대상을 컴포넌트 스캔 대상에서 제외하는 방법 (특수한 경우에만 사용)
                    ○ @ComponentScan 어노테이션의 excludeFilters 속성을 추가한다.
                    ○ excludeFilters의 값으로 @Filter 어노테이션을 추가한다.
                    ○ @Filter 어노테이션의 속성인 type과 classes에 각각 FileterType.ANNOTATION과 스캔 대상에서 제외할 클래스의 명을 작성한다.
                        작성 예시)
                            @Configuration
                            @ComponentScan(
                                excludeFilters = @Filter(type = FilterType.ANNOTATION, classes = Configuration.class)
                            )
                            public class ComponentSscanTest {
                            
                            }

                ● 탐색할 패키지의 시작 위치를 지정하는 방법
                    ○ @ComponentScan 어노테이션에 basePackages 속성을 준다.
                        예시) @ComponentScan(basePackages = "com.practice")

                    ○ 2개 이상의 패키지를 지정하고 싶을 때는 {}를 사용한다.
                        예시) @ComponentScan(basePackages = {"com.practiceA", "com.com.practiceB"})

                ● 컴포넌트 스캔의 특징
                    ○ basePackages 속성을 지정하지 않으면 @ComponentScan 어노테이션이 붙은 설정 정보 클래스의 패키지가 시작 위치가 된다.

                    
                ● 컴포넌트 스캔의 기본 대상
                    ○ @Component 어노테이션 : 컴포넌트 스캔에서 사용
                    ○ @Controlller 어노테이션 : 스프링 MVC 컨트롤러에서 사용
                    ○ @Service 어노테이션 : 스프링 비즈니스 로직에서 사용
                    ○ @Repository 어노테이션 : 스프링 데이터 접근 계층에서 사용
                    ○ @Configuration 어노테이션 : 스프링 설정 정보에서 사용

                
                ● 컴포넌트 스캔의 필터 기능
                    ○ includeFilters 속성 : 컴포넌트 스캔 대상을 추가로 지정한다.
                    ○ excludeFilters 속성 : 컴포넌트 스캔에서 제외할 대상을 지정한다

                ● @Filter 어노테이션의 type 속성의 종류
                    ○ FilterType.ANNOTATION: 기본값, 애노테이션을 인식해서 동작한다.
                    ○ FilterType.ASSIGNABLE_TYPE: 지정한 타입과 자식 타입을 인식해서 동작한다.
                    ○ FilterType.ASPECTJ: AspectJ 패턴 사용
                    ○ FilterType.REGEX: 정규 표현식
                    ○ CUSTOM: TypeFilter 이라는 인터페이스를 구현해서 처리
            </pre>
        </span>
    </section>

    <br>

    <section id="IOC">
        <span>
            <bold>스프링 3대 요소 - 제어 역전 (IOC)</bold>
        </span>
        <span>
            <pre>
                ● 제어 역전 (Inversion of Control)
                    ○ 객체의 생성에서부터 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀌는 것
                    ○ 스프링 컨테이너가 필요에 따라 개발자 대신 빈들을 관리해주는 행위 (생명 주기 관리 : 생성 → 의존성 설정 → 초기화 → 소멸)
                ● 제어 역전의 등장 배경
                    ○ 기존의 객체 관리는 개발자가 직접 했어야 했다. (new, 의존성 맺기, 초기화 등등)
                    ○ 번거로운 객체의 생명주기 관리를 대신 해줄 무언가가 필요했다.
                ● 제어 역전 방법
                    ○ xml 파일을 통해서 빈을 등록
                    ○ 어노테이션을 통해서 빈을 등록
                ● 제어 역전의 장점
                    ○ 개발자는 객체 관리에 덜 신경쓸 수 있게 되어 다른 부분에 더 집중할 수 있게 됨
                    ○ 약한 결합을 이용하여 객체 간 의존관계를 쉽게 변경할 수 있음
                    ○ 코드의 재사용성과 유지보수성을 높인다. 
            </pre>
        </span>
    </section>

    <br>

    <section id="DI">
        <span>
            <bold>스프링 3대 요소 - 의존성 주입 (DI)</bold>
        </span>
        <span>기본적인 사용법
            <pre>
                ● 의존성 주입 (Dependency Injection) : 어떤 객체에 스프링 컨테이너가 또 다른 객체와 의존성을 맺어주는 행위

                코드)
                    public class TestA{ }

                    @Component
                    public class TestB{ }

                    public static void main(String[] args) {
                        TestA testA = new TestA();

                        @Autowired
                        TestB testB;
                    }
            </pre>
        </span>
        <span>어노테이션의 종류에 따른 다양한 의존성 주입 방법
            <pre>
                ● @Autowired : 해당하는 타입의 객체를 찾아서 자동으로 할당하는 어노테이션
                    ○ 생성자, 메소드, 멤버변수 위에 모두 사용 가능
                    ○ 스프링 컨테이너는 @Autowired가 붙어 있는 것을 확인하는 순간 해당 변수의 타입을 체크하고 그 타입의 객체가 메모리 상에 존재하면 해당 변수에 객체를 대입한다.
                    ○ 만약 @Autowired를 선언한 것에 대한 객체가 존재하지 않는 타입이라면 NoSuchBeanDefinitionException이 발생한다.
                    ○ 탐색 순서 : 타입 -> 이름 -> @Qualifier -> 실패
                    ○ 만약 찾는 빈 객체가 없는 경우 발생하는 예외를 피하고 싶다면 @Autowired(required=false)처럼 쓰면 된다.
                    ○ @Autowired(required=false)를 통해 찾는 객체가 없는 경우에 대한 null 처리 소스도 작성해야 한다.

                ● @Qualifier : @Autowired와 함께 사용하는 어노테이션
                    ○ 특정 객체의 이름을 사용하여 의존성 주입할 때 사용
                    ○ 인터페이스에 대해 @Autowired가 실행됬을 때, 적절한 빈을 컨테이나가 찾지 못하는 경우에 사용한다.
                    ○ @Qualifier를 사용하여 직접 빈의 이름을 지정하여 컨테이너가 어떤 객체를 주입할지 선택할 수 있게 해준다.
                    ○ 빈이 등록된 xml 파일에서 미리 qualifier 태그를 통해 지정을 해둬야 한다.
                    ○ 빈 자체의 id가 아닌 qualifier 태그에 명시한 value를 통해 이름을 지정한다.
                    ○ @Autowired를 먼저 사용한 후 @Qualifier("명칭")을 사용하면 된다.

                ● @Inject : 해당하는 타입의 객체를 찾아서 자동으로 할당하는 어노테이션
                    ○ 생성자, 메소드, 멤버변수 위에 모두 사용 가능
                    ○ 탐색 순서 : 타입 -> @Named-> 이름 -> 실패

                ● @Named : @Inject 함께 사용하는 어노테이션
                    ○ 특정 객체의 id를 사용하여 의존성 주입할 때 사용
                    ○ @Inject 먼저 사용한 후 @Named("id명")을 사용하면 된다.

                ● @Resource : 주입하려고 하는 객체의 id가 일치하는 객체를 자동으로 주입한다.
                    ○ 메소드, 멤버변수 위에 사용 가능
                    ○ 사실상 @Autowired + @Qualifier
                    ○ 탐색 순서 : 이름 -> 타입 -> @Qualifier -> 실패
                    ○ @Resource나 @Resource(name="등록된 빈의 id")로 사용한다.
                    ○ &lt;context:annotation-config/>를 xml 파일에 추가해야지 사용할수 있다.
            </pre>
        </span>
    </section>

    <br>

    <section id="AOP">
        <span>
            <bold>스프링 3대 요소 - 관점 지향 프로그래밍 (AOP)</bold>
        </span>
        <span>정의
            <pre>
                ● AOP (Aspect Oriented Programming) : 관점지향적 프로그래밍
                ● 기능을 비즈니스 로직과 공통 모듈로 구분한 뒤에 개발자의 코드 밖에서 필요한 시점에 비즈니스 로직에 삽입하여 실행되도록 하는 방법
                ● OOP를 더욱 보완 확장하여 OOP를 OOP답게 사용할 수 있도록 도와주는 개념
                ● DI가 의존성의 주입이라면, AOP는 기능의 주입이다.
            </pre>
        </span>
        <span>AOP가 필요한 상황
            <pre>
                ● 중복을 최대한 줄여서 적은 량의 코드 수정만으로도 프로젝트의 전체적인 부분을 변경할 수 있도록 하기 위해서
            </pre>
        </span>
        <span>AOP의 특징
            <pre>
                ● 중복되는 코드가 줄어든다.
                ● 프로젝트의 유지보수를 효율적으로 할 수 있다.
                ● 생산성이 높아진다.
                ● 재활용성이 극대화된다.
                ● 변화에 대한 수용성이 높아진다.
            </pre>
        </span>
        <span>AOP 용어
            <pre>
                ● Joinpoint
                    ○ Advice를 적용가능한 지점
                    ○ 특정 작업이 실행되는 시점
                    ○ 스프링은 프록시를 이용해서 AOP를 구현하기 때문에 필드 값 변경에 대한 Joinpoint는 불가능하다.
                    ○ 메소드 호출에 대한 Joinpoint 가능
                ● Aspect
                    ○ 여러 객체에 공통으로 적용되는 기능
                    ○ 일정한 패턴을 가지는 클래스에 Advice를 적용하도록 지원할 수 있는 것
                    ○ Advice + Pointcut
                    ○ 예시) 트랜잭션, 로그, 보안, 인증 등등
                ● Weaving
                    ○ AOP에서 Joinpoint들을 Advice로 감싸는 과정
                    ○ Weaving 하는 작업을 도와주는 것이 AOP Tool의 역할이다.
                ● Advice
                    ○ Joinpoint에서 실행되어야 하는 코드
                ● Target
                    ○ 실질적인 비즈니스 로직을 구현하고 았는 코드
                    ○ Advice를 받을 대상
                    ○ 비즈니스 로직을 수행하는 클래스 또는 프록시 객체
                ● Pointcut
                    ○ 실제 Advice가 적용되는 Joinpoint
                    ○ Joinpoint의 부분 집합
                    ○ 스프링에서는 정규식이나 AspectJ 문법을 이용해서,
                      Target 클래스와 Advice가 결합 (Weaving) 될 때
                      둘 사이의 결합 규칙을 정의할 수 있다.
            </pre>
        </span>
        <span>AOP 적용 방법
            <pre>
                ● xxxxxxx
            </pre>
        </span>
    </section>

    <br>

    <section id="psa">
        <span>
            <bold>PSA (Portable Service Abstraction)</bold>
        </span>
        <span>쿠키 생성하기
            <pre>
                ● 정의 : xxx
            </pre>
        </span>
    </section>

    <br>

    <section id="cookie">
        <span>
            <bold>쿠키</bold>
        </span>
        <span>쿠키 생성하기
            <pre>
                1. 쿠키 객체 생성하기
                    Cookie cookie = new Cookie("속성명", "값");

                2. HttpServletResponse 객체에 추가하기 (변수명 : response)
                    response.addCookie(cookie);
            </pre>
        </span>
        <span>쿠키 사용하기
            <pre>
                ● 컨트롤러 메소드의 매개변수로 쿠키 사용
                    코드)
                        @RequestMapping("/main")
                        public String mallIndex(@CookieValue(value="가져올쿠키명", required=false) Cookie cookie, HttpServletRequest request) {
                            if(cookie != null)
                                System.out.pringln("쿠키값 : "+cookie);

                            return "/common/main";
                        }

                ● 주의점
                    ○ required=false를 입력하지 않으면 만약 쿠키가 없을 때 에러가 발생한다.
            </pre>
        </span>
        <span>쿠키 삭제하기
            <pre>
                cookie.setMaxAge(0); //존재 시간을 0초로 하기
            </pre>
        </span>
    </section>

    <br>

    <section id="session">
        <span>
            <bold>세션</bold>
        </span>
        <span>세션 얻기
            <pre>
                ● 방법 1 : HttpServletRequest를 통한 세션 얻기
                    ○ 컨트롤러 클래스의 메소드의 매개변수로 HttpServletRequest 객체 명시하기
                    ○ 해당 객체의 명이 request라고 했을 때
                        코드)
                            HttpSession session = request.getSession();
        
                ● 방법 2 : HttpSession을 통한 세션 얻기
                    ○ 컨트롤러 클래스의 매개변수로 HttpSession 객체 명시하기

                ● 방법 1과 방법 2의 차이점
                    ○ HttpServletRequest
                        (1) 생성 시점 : 클라이언트가 최초로 접속할 때
                        (2) 삭제 시점 : 클라이언트가 접속을 종료할 때
                        (3) 유지 기간 : 클라이언트가 접속 중인 동안 존재
                    ○ HttpSession
                        (1) 생성 시점 : 클라이언트가 요청 시
                        (2) 삭제 시점 : 서버가 응답 시
                        (3) 유지 기간 : Request 중인 동안인만 존재
            </pre>
        </span>
        <span>세션에 값 설정하기
            <pre>
                1. 세션 객체를 얻는다. (변수명 : session)
                2. session.setAttribute("속성명","값");
            </pre>
        </span>
        <span>세션에서 값 가져오기
            <pre>
                1. 세션 객체를 얻는다. (변수명 : session)
                2. session.getAttribute("속성명","값");
            </pre>
        </span>
        <span>세션 삭제하기
            <pre>
                1. 세션 객체를 얻는다. (변수명 : session)
                2. session.invalidate();
            </pre>
        </span>
    </section>

    <br>

    <section id="redirect">
        <span>
            <bold>리다이렉트</bold>
        </span>
        <span>
            <pre>
                ● 정의 : 지금의 페이지에서 특정 페이지로 전환하는 기능
            </pre>
        </span>
        <span>리다이렉트 방법
            <pre>
                ●컨트롤러 메소드의 return 주소에 redirect 작성하기
                    예시)
                        return "redirect:/common/main";
            </pre>
        </span>
    </section>

    <br>

    <section id="interseptor">
        <span>
            <bold>인터셉터</bold>
        </span>
        <span>
            <pre>
                ● 정의 : 컨트롤러에 들어오는 요청인 HttpRequest와 컨트롤러가 응답하는 HttpResponse를 가로채는 역할
            </pre>
        </span>
        <span>인터셉터 사용 방법
            <pre>
                ● spirng-servlet.xml에 인터셉터 태그를 통해서 사용 설정하기
                    코드)
                        <!-- Interceptors -->
                        &lt;mvc:interceptors>
                            &lt;mvc:interceptor>
                                &lt;mvc:mapping path="/**" /> 
                                &lt;bean class="com.project.util.MyInterceptor" />
                            &lt;/mvc:interceptor>
                        &lt;/mvc:interceptors>

                ● 인터셉터 클래스 구현하기
                    ○ 방법 1 : HandlerInterceptor 인터페이스 구현하기
                        (1) preHandle() : 컨트롤러로 보내기 전에 처리하는 인터셉터, return 값이 false면 컨트롤러로 요청을 안한다.
                        (2) postHandle() : 컨트롤러의 handler가 끝나면 처리된다.
                        (3) afterCompletion() : 뷰까지 처리가 끝난 후에 처리된다.
            </pre>
        </span>
        <span>인터셉터와 필터의 차이
            <pre>
                ● 인터셉터
                    ○ 호출 시점 : DispatcherServlet이 실행된 후
                    ○ 설정 위치 : spirng-servlet.xml
                    ○ 구현 방식 : 설정 + 메소드 구현

                ● 필터
                    ○ 호출 시점 : DispatcherServlet이 실행되기 전
                    ○ 설정 위치 : web.xml
                    ○ 구현 방식 : 설정
            </pre>
        </span>
    </section>

    <br>

    <section id="annotation">
        <span>
            <bold>어노테이션</bold>
        </span>
        <span>어노테이션 목록
            <pre>
                ● @Autowired
                ● @Bean
                ● @Component
                ● @ComponentScan
                ● @Configuration
                ● @Controlller
                ● @Documented
                ● @Filter
                ● @GetMapping
                ● @Inject
                ● @interface
                ● @Lookup
                ● @Named
                ● @PostConstruct
                ● @PostMapping
                ● @PreDestory
                ● @Qualifier
                ● @Repository
                ● @RequiredArgsConstructor
                ● @Resource
                ● @ResponseBody
                ● @Retention
                ● @Scope
                ● @Service
                ● @Target
                ● @Test
            </pre>
        </span>
        <span>사용자 정의 어노테이션
            <pre>
                ● xxxxxxxxx
            </pre>
        </span>
    </section>

    <div id="remote">
        <section id="remote_setcion">
            <select id="remote_menu">
                <option value="intro">스프링 프레임워크</option>
                <option value="base">이론</option>
                <option value="bean">스프링 빈</option>
                <option value="beanLifeCycle">빈 생명 주기</option>
                <option value="beanScope">빈 스코프</option>
                <option value="singleton">싱글톤 스코프</option>
                <option value="prototype">프로토타입 스코프</option>
                <option value="component">컴포넌트 스캔</option>
                <option value="IOC">제어 역전 (IOC)</option>
                <option value="DI">의존성 주입 (DI)</option>
                <option value="AOP">관점 지향 프로그래밍 (AOP)</option>
                <option value="psa">PSA</option>
                <option value="cookie">쿠키</option>
                <option value="session">세션</option>
                <option value="redirect">리다이렉트</option>
                <option value="interseptor">인터셉터</option>
                <option value="annotation">어노테이션</option>
            </select>
        </section>
    </div>

    <script src="./remote.js"></script>
</body>
</html>