<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JPA 공부</title>
    <link rel="stylesheet" href="./css/index.css" />
  </head>
  <body>
    <section id="intro">
      <header class="note_title">JPA</header>
      <ul>
        <li>JPA
          <pre>
            ● JPA (Java Persistence API) : Java에 대한 ORM 기술 표준
            ● 인터페이스 모음집
            ● JPA 인터페이스를 구현한 오픈소스 종류 : Hibernate, EclipseLink, DataNucleus
          </pre>
        </li>
        <li>JPA의 사용 이유
          <pre>
            ● SQL 중심이 아닌 객체 중심으로 개발
                ○ SQL 작성시 코드 반복의 감소
                ○ 모델링 문제 해결
            ● CRUD가 간단하다.
                (※ 특히 수정이 간단하다. => 객체를 변경하면 자동으로 Update Query 실행)
            ● 유지보수
                ○ 기존 : 필드 변경 시 관련 SQL 모두 수정
                ○ JPA 사용 : 필드만 추가 (※ 이유 : SQL은 JPA가 대신 처리해주기 때문)
            ● Object와 RDB 간의 패러다임 불일치 해결
            ● 최적화 기능
                ○ 캐싱 기능 : 1차 캐시와 동일성 보장
                ○ 버퍼링 기능 : 트랜잭션을 지원하는 쓰기 지연
                ○ 지연 로딩 : 객체가 실제로 사용될 때 로딩하는 전략
                ○ 즉시 로딩 : Join SQL로 한 번에 연관된 객체까지 미리 조회하는 전략
            ● 데이터 접근 추상화와 벤더 독립성
            ● 표준
          </pre>
        </li>
        <li>JPA 동작 과정
          <pre>
            ● 기본 구조
                ○ 애플리케이션과 JDBC 사이에서 동작
                ○ 개발자가 JPA 사용시 JPA 내부에서 JDBC API를 통해서 SQL을 호출하여 DataBase와 통신

            ● 저장 과정
                1. 개발자가 저장을 원하는 객체를 JPA에 전달
                2. JPA가 Entity를 분석
                3. JPA가 Insert SQL 생성
                4. JPA가 JDBC API를 사용하여 SQL을 DB에 전송

            ● 조회 과정
                1. 개발자가 조회를 원하는 객체의 PK 값을 JPA에 전달
                2. JPA가 Entity의 매핑 정보를 바탕으로 적절한 Selete SQL 생성
                3. JPA가 JDBC API를 사용하여 SQL을 DataBase에 전달
                4. DataBase가 JPA에게 결과를 전달
                5. JPA가 DataBase한테 전달받은 결과를 객체에 매핑하여 전달
          </pre>
        </li>
      </ul>
    </section>

    <section id="installAndConnnecting">
      <header class="note_title">설치 및 연결</header>
      <ul>
        <li>설치 및 연결
          <pre>
            ● pom.xml에 dependency 추가
                &lt;dependency>
                    &lt;groupId>org.springframework.boot&lt;/groupId>
                    &lt;artifactId>spring-boot-starter-data-jpa&lt;/artifactId>
            &lt;/dependency>
          </pre>
        </li>
      </ul>
    </section>

    <br />

    <section id="JpaRepository">
      <header class="note_title">JPA - Repository</header>
      <ul>
        <li>Repository 제작법
          <pre>
            1. JPA의 Repository로 사용할 인터페이스를 만든다.
            2. 해당 인터페이스에 org.springframework.data.jpa.repository.JpaRepository를 import한다.
            3. JpaRepository 클래스를 JpaRepository&lt;Entity형식,ID형식>으로 상속받는다.
                    예시) public interface BookRepository extends JpaRepository&lt;BookEntity, Long>
          </pre>
        </li>
        <li>Repository 종류
          <pre>
            ● Repository&lt;T, ID>
            ● CrudRepository&lt;T, ID>
            ● PagingAndSortingRepository&lt;T, ID>
            ● JpaRepository&lt;T, ID>

            ※ T : Entity의 타입클래스, ID : Primary Key의 Type 
          </pre>
        </li>
        <li>Repository의 기본 메소드 형식
          <pre>
            ● find~ : 특정 조건을 만족하는 데이터를 가져오기
            ● save~ : 해당 테이블에 데이터를 저장하기
            ● delete~ : 특정 조건을 만족하는 데이터를 삭제
            ● flush() : 영속성 컨텍스트의 변경 내용을 DataBase에 동기화
            ● existsById(ID id) : id값을 통해 데이터 존재 여부 판단 (Boolean 값 리턴)
            ● count() : 해당 테이블의 전체 데이터 개수를 리턴 (long 값 리턴)
          </pre>
        </li>
        <li>@Query 어노테이션
          <pre>
            ● JPA의 자동 SQL 생성기능 대신에 직접 쿼리를 작성할수 있게 해주는 어노테이션
              기본 예시)
                @Query(value = "select * from user limit 1;", nativeQuery = true)
                Map&lt;String, Object> findOneUser();

            ● 옵션
              ○ value : SQL 쿼리를 작성하는 옵션
              ○ nativeQuery : 해당 옵션이 추가되어있으면 DB에서 직접 쿼리문을 작성하듯이 작성할수 있게 해준다.

            ● 주의점
              ○ 호출하는 테이블명에 반드시 별칭을 추가해서 사용해야 한다.

            ● 데이터 치환
              ○ ? 사용 : ?1이나 ?2처럼 각각의 순서에 맞는 숫자를 붙여서 파라미터가 들어갈 순서대로 쿼리에 명시한다.
              ○ :파라미터명 : :name이나 :age처럼 필요한 파라미터명에 맞춰서 쿼리에 명시하면 된다.
                ※ 기존에는 @Param("name") String name처럼 파라미터에 어노테이션이 필요했다.
                ※ 현재는 파라미터명만 잘 맞춰주면 알아서 잘 치환된다. (Spring 4 이상 + Java 8 이상)
          </pre>
        </li>
        <li>JPA를 통한 페이징 처리
          <pre>
            ※ PagingAndSortingRepository 인터페이스의 구현 필요

            ● Page&lt;VO타입> 객체명 = repository객체.find~(new PageRequest(page, size));
                ○ page : 찾을 페이지, 시작값 : 0
                ○ size : 한 페이지의 사이즈, 기본값 : 20

            ● 컨트롤러에서 Pageable 변수 받기
                예시)
                    @GetMapping("/users")
                    public List&lt;User> findAllUser(Pageable pageable) { ... }   
                    //GET /users?page=3&size=10&sort=id,DESC

            ● @PageableDefault (페이징을 위한 기본값 설정 어노테이션)
                예시)
                    @GetMapping("/users")
                    public List&lt;User> findAllUser(@PageableDefault(size=100, sort="id", direction = Sort.Direction.DESC) Pageable pageable) { ... } 

            ● 페이징 기본값 설정법 - application.properties
                spring.data.web.pageable.default-page-size=페이지_크기
          </pre>
        </li>
        <li>쿼리 메소드란?
          <pre>
            ● 메서드 이름으로 우리가 원하는 기능을 수행할 쿼리가 자동으로 생성해줄수 있도록 일정 규칙에 맞게 이름을 정의하여 사용하는 메서드
          </pre>
        </li>
        <li>쿼리 메소드 - 실행문
          <pre>
            ● 데이터 검색 (가독성을 위해 나눠져있을 뿐 모두 결과가 같다.)
                ○ findBy~
                ○ readBy~
                ○ getBy~
                ○ queryBy~
                ○ searchBy~
                ○ streamBy~

            ● 존재 여부 확인
                ○ existsBy~
            
            ● 개수 확인
                ○ countBy~
            
            ● 데이터 삭제
                ○ deleteBy~
                ○ removeBy~

            ● 처음부터 n개의 데이터 가져오기
                ○ ~First(숫자)~
                ○ ~Top(숫자)~
            
            ● 중복 제거
                ○ ~Distinct~
          </pre>
        </li>
        <li>쿼리 메소드 - 조건문
          <pre>
            ● 조건 연결
                ○ ~And~
                ○ ~Or~

            ● 조건 부정
                ○ ~Not~
                ○ ~IsNot~

            ● 참/거짓 체크
                ○ True
                ○ IsTrue
                ○ NotFalse
                ○ IsNotFalse

            ● 날짜 비교
                ○ 이전
                    ○ ~Before
                    ○ ~IsBefore
                ○ 이후
                    ○ ~After
                    ○ ~IsAfter
            ● 수치 비교
                ○ 작다
                    ○ ~LessThan
                    ○ ~IsLessThan
                ○ 작거나 같다
                    ○ ~LessThanEqual
                    ○ ~IsLessThanEqual
                ○ 크다
                    ○ ~GreaterThan
                    ○ ~IsGreaterThan
                ○ 크거나 같다
                    ○ ~GreaterThanEqual
                    ○ ~IsGreaterThanEqual

            ● 범위
                ○ m에서 n사이에 포함
                    ○ ~Between
                    ○ ~IsBetween
                ○ m,n,o...중에 포함
                    ○ ~In
                    ○ ~IsIn

            ● 단어 포함
                ○ ~로 시작
                    ○ ~StartingWith
                    ○ ~IsStartingWith
                    ○ ~StartsWith
                ○ ~로 종료
                    ○ ~EndingWith
                    ○ ~IsEndingWith
                    ○ ~EndsWith
                ○ ~ 포함
                    ○ ~Like
                    ○ ~IsLike
                    ○ Containing
                    ○ IsContaining
                    ○ Contains

            ● Null 체크
                ○ Null
                ○ IsNull
                ○ NotNull
                ○ IsNotNull

            ● Empty 체크
                ○ Empty
                ○ IsEmpty
                ○ NotEmpty
                ○ IsNotEmpty
          </pre>
        </li>
        <li>쿼리 메소드 - 정렬하기
          <pre>
            ● 단순 정렬
                ○ ~OrderBy칼럼명
                ○ ~OrderBy칼럼명Asc
                ○ ~OrderBy칼럼명Desc
            
            ● 정렬 방식 추가
                예시)
                    //List&lt;User> findFirstByName(String name, Sort sort)
                    userRepository.findFirstByName("HongGilDong", Sort.by(Order.desc("id"), Order.asc("email")))
          </pre>
        </li>
      </ul>
    </section>

    <br />

    <section id="jpaEntity">
      <header class="note_title">JPA - Entity</header>
      <ul>
        <li>Entity Class 기본 생성법
          <pre>
            1. JPA의 Entity로 사용할 클래스를 만든다.
            2. 해당 클래스에 javax.persistence.Entity를 import 하고 @Entity를 추가해준다.
            3. 필요한 필드들을 필요한 어노테이션을 추가하면서 생성해준다.
          </pre>
        </li>
        <li>Entity Class 관련 어노테이션
          <pre>
            ● @Entity : 해당 클래스를 Entity로 등록한다.
              ○ name 옵션 : JPA에서 사용할 엔티티 이름을 지정한다. 보통 생략한다.
                예시) name = "Member"
            ● @Table : 매핑시킬 테이블을 직접 지정해준다.
              ○ name 옵션 : 매핑시킬 테이블의 이름을 명시한다.
                예시) name = "user"
              ○ indexes 옵션
                예시) indexes = { @Index(columnList = "name")}
              ○ uniqueConstraints 옵션 :
                  (1)매핑될 테이블에서 자신이 명시한 칼럼에 Unique 제약조건을 추가한다.
                  (2) 보통 columnNames 속성은 name 속성과 같이 사용한다. //이유 : 제약조건명 랜덤생성
                  예시) uniqueConstraints = {@UniqueConstraint(columnNames = {"email"})})
            ● @MappedSuperclass : 해당 어노테이션을 명시한 클래스를 상속받는 Entity Class는 해당 슈퍼 클래스의 필드를 칼럼으로 사용한다. 

            ● @Id : 해당 필드가 Primary Key이란 것을 의미한다.
            ● @GeneratedValue : hibernate의 sequence를 통해서 자동 증가하는 값이다.
              ○ strategy 옵션 : persistence provider가 Entity의 기본키를 생성하는 방법 (기본값 : AUTO)
                ○ AUTO : persistence provider가 특정 데이터베이스에 맞게 자동 선택하는 방법
                ○ IDENTITY : 데이터베이스의 identity 컬럼을 이용하는 방법 (MySQL)
                ○ SEQUENCE : 데이터베이스의 시퀀스 컬럼을 이용하는 방법 (ORACLE)
                ○ TABLE : 유일성이 보장된 데이터베이스 테이블을 이용하는 방법 (모든 DataBase에서 사용), @TableGenerator 필요
                예시) strategy=GenerationType.IDENTITY
            ● @Column : 해당 필드에 옵션을 추가한다.
              ○ name 옵션 : 테이블에서 사용되는 실제 칼럼명을 의미한다. 보통은 필드명과 칼럼명을 맞춘다.
                예시) name="homeAddress"
              ○ nullable 옵션 : null 가능 여부
                예시) nullable=false //필수값임을 의미
              ○ length 옵션 : 최대 길이 설정, String 타입에만 사용
                예시) length=10
              ○ unique 옵션 : 해당 필드가 unique함을 의미
                예시) unique=true
              ○ insertable 옵션 : 해당 필드의 값을 추가가능한지에 대한 여부
                예시) insertable = false
              ○ updatable 옵션 : 해당 필드의 값을 변경가능한지에 대한 여부
                예시) updatable = false

            ● @NonNUll : 해당 필드는 반드시 값이 존재해야 한다.
            ● @Enumerated : Enum 타입 매핑
              ○ @Enumerated(value = EnumType.PRDINAL) : enum의 순서를 데이터베이스에 저장
                ※ 순서 변경 여부때문에 사용하지 않는다.
              ○ @Enumerated(value = EnumType.STRING) : enum의 이름을 데이터베이스에 저장
            ● @Temporal : 날짜 타입 매핑
              ○ @Temporal(TemporalType.DATE) : DB의 date 타입과 매핑
              ○ @Temporal(TemporalType.TIME) : DB의 time 타입과 매핑
              ○ @Temporal(TemporalType.TIMESTAMP) : DB의 timestamp 타입과 매핑
              ※ Java 8의 LocalDate 사용시에는 생략가능한 어노테이션
            ● @Lob : DB에서 Varchar를 넘어서는 큰 내용을 넣고 싶은 경우에 사영하는 어노테이션
            ● @Transient : DB에 관계없이 메모리에서만 사용하고자 하는 필드에만 추가하는 어노테이션
                => 임시 보관 데이터용으로 사용하는 어노테이션
          </pre>
        </li>
        <li>Entity Listener란?
          <pre>
            ● Entity의 변화를 감지해서 같은 테이블이나 다른 테이블의 데이터를 조작하기 위한 이벤트 리스너
            ● @SpringBootApplication이 있는 Main Class에 @EnableJpaAuditing 어노테이션을 추가해서 사용한다.
          </pre>
        </li>
        <li>Entity Listener의 종류
          <pre>
            ● @PrePersist : insert가 실행되기 전에 작동
            ● @PostPersist : insert가 실행된 후에 작동

            ● @PreUpdate : update가 실행되기 전에 작동
            ● @PostUpdate : update가 실행된 후에 작동

            ● @PreRemove : delete가 실행되기 전에 작동
            ● @PostRemove : delete가 실행되기 전에 작동
            ● @PostLoad : select가 실행된 후에 작동
          </pre>
        </li>
        <li>Entity Listener 생성 및 적용법
          <pre>
            1. 별도의 listener용 패키지를 만든다.
            2. listener로 사용할 클래스를 만든다.
            3. 해당 클래스 안에 필요한 Entity Listener를 작성해준다.
            4. Entity Listener를 사용할 Entity Class에 가서 @EntityListeners(value = EntityListener클래스명.class)을 추가해준다.
          </pre>
        </li>
      </ul>
    </section>

    <br />

    <section id="relation">
      <header class="note_title">연관관계</header>
      <ul>
        <li>1 : 1 관계
          <pre>
            ● 단방향
              @Entity
              public class User {
                  ...
                  @OneToOne
                  @JoinColumn(name = "참조하는_칼럼명")
                  private Address address; //참조하는 Entity Class
              }

            ● 양방향
              @Entity
              public class User {
                  ...
                  @OneToOne
                  @JoinColumn(name = "id") //Address Class에 있는 id 필드를 외래키로 지정
                  private Address address; //참조하는 Entity Class
              }
              @Entity
              public class Address {
                  @Id
                  @Column(name = "userID")
                  String id;
                  ...
                  @OneToOne(mappedBy = "address")
                  private User user; //User Class에 있는 address 필드와 매핑
              }

            ※ optional = false 옵션을 추가하면 반드시 null을 허용하지 않는 상태로 지정한다.
          </pre>
        </li>
      </ul>
    </section>

    <br />

    <section id="h2db">
      <header class="note_title">H2 Database</header>
      <ul>
        <li>H2 Database
          <pre>
            ● Java 기반의 경량화된 관계형 DB
            ● 파일로 저장해서 실제 DB처럼 데이터 유지 가능
            ● 메모리 DB로 사용해서 실제 인스턴스가 동작 시점에만 유지하는 것도 가능
            ● 테스트 DB로 주로 사용
            ● 유지보수 시 JUnit 테스트용으로 주로 사용
            ● 서버를 재기동시 초기화
          </pre>
        </li>
        <li>설치방법 (Spring Boot 기준)
          <pre>
            1. pom.xml에 dependency 추가
                &lt;dependency>
                    &lt;groupId>com.h2database&lt;/groupId>
                    &lt;artifactId>h2&lt;/artifactId>
                    &lt;scope>runtime&lt;/scope>
                &lt;/dependency>

            2. application.properties 파일에 정보 추가 (※ 기본 계정 : sa)
                spring.datasource.url=jdbc:h2:~/DB명; #DB 고정
                spring.datasource.driverClassName=org.h2.Driver
                spring.datasource.username=sa
                spring.datasource.password=
                spring.h2.console.enabled=true
                spring.h2.console.path=/h2-console /*기본값*/
            
            3. 프로젝트 실행
            4. http://localhost:포트주소/h2-console로 이동
          </pre>
        </li>
        <li>자신의 memory DB의 주소를 알기 위한 코드
          <pre>
            package com.example.demo;

            import java.sql.SQLException;

            import org.springframework.beans.factory.annotation.Autowired;
            import org.springframework.boot.ApplicationArguments;
            import org.springframework.boot.ApplicationRunner;
            import org.springframework.stereotype.Component;

            import javax.sql.DataSource;
            import java.sql.Connection;

            @Component
            public class DatabaseConfig implements ApplicationRunner {

                @Autowired
                DataSource dataSource;

                @Override
                public void run(ApplicationArguments args) throws SQLException {
                    try(Connection connection = dataSource.getConnection()){
                        System.out.println(connection.getMetaData().getURL());
                        System.out.println(connection.getMetaData().getUserName());
                    } catch (Exception e){
                        System.out.println(e);
                    }
                }
            }
          </pre>
        </li>
      </ul>
    </section>

    <br />

    <section id="log">
      <header class="note_title">로그 출력하기</header>
      <ul>
        <li>JPA 쿼리 로그 출력 설정법
          <pre>
            #JPA 로그 출력 설정
            spring.jpa.show-sql=true

            #JPA 로그의 모양을 단정하게 하기
            spring.jpa.properties.hibernate.format_sql=true
            
            #JPA 로그의 ? 부분을 실제 값으로 치환
            logging.level.org.hibernate.type.descriptor.sql=TRACE
          </pre>
        </li>
      </ul>
    </section>

    <div id="remote">
      <section id="remote_setcion">
        <select id="remote_menu" onchange="move_section()">
          <option value="intro">JPA</option>
          <option value="installAndConnnecting">설치 및 연결</option>
          <option value="JpaRepository">JPA - Repository</option>
          <option value="jpaEntity">JPA - Entity</option>
          <option value="relation">연관관계</option>
          <option value="h2db">H2 Database</option>
          <option value="log">로그 출력하기</option>
        </select>
      </section>
    </div>
  </body>
</html>
